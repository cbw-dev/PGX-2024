# Module 2: Data Preparation for Pharmacogenomic Analysis

## Lecture

<iframe width="640" height="360" src="https://www.youtube.com/embed/hpoijfpSAZ0?si=XmeqIOn0i_JRDXJj" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

<br>

<iframe src="https://drive.google.com/file/d/13hEXKfqoDlQp6L-PAzH--GCkcDQhzmkh/preview" width="640" height="480" allow="autoplay"></iframe>

## Lab

```{r global_knitr_opts_2, echo=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  include = TRUE,
  warning = FALSE,
  message = TRUE
)
```

```{r eval=TRUE, echo=FALSE}
PGx <- BiocStyle::Biocpkg("PharmacoGx")
CGx <- BiocStyle::Biocpkg("CoreGx")
TGx <- BiocStyle::Biocpkg("ToxicoGx")
RGx <- BiocStyle::Biocpkg("RadioGx")
Xv <- BiocStyle::Biocpkg("Xeva")
DT <- BiocStyle::CRANpkg("data.table")
SE <- BiocStyle::Biocpkg("SummarizedExperiment")
MAE <- BiocStyle::Biocpkg("MultiAssayExperiment")
```

### Overview

#### Instructor(s) Name and Contact Information

* Jermiah J. Joseph <jermiah.joseph@uhn.ca>
* Almas Khan <almas.khan@uhn.ca>
* Julia Nguyen <julia.nguyen@uhn.ca>

#### Learning Goals

* Understand the data structure of a `PharmacoSet`
* Learn how to access features and metadata from a PharmacoSet
* Learn how to plot batch effects using PCA and run correction method (SVA)
* Learn how to filter out outliers and missing values

#### Learning Objectives

* Describe the use cases for `r PGx` in Pharmacogenomics
* Understand the structure of the `CoreSet` and `PharmacoSet` classes to facilitate their use in subsequent analyses
* Download/load a `PharmacoSet` using `r PGx` or [orcestra.ca](https://orcestra.ca)
* Subset and filter a `PharmacoSet` by samples and/or treatments
* Access the molecular features, dose-response and metadata contained within the `PharmacoSet`
* Perform quality control on a `PharmacoSet` by identifying and removing outliers and missing values
* Perform batch correction on a `PharmacoSet` using the `sva` package

```{r load_packages_2, eval=TRUE, echo=FALSE, include=FALSE}
suppressPackageStartupMessages({
  library(CBWWorkshop2024)
  library(PharmacoGx)
  library(data.table)
  library(ggplot2)
  library(ggpubr)
  library(sva)
})
```

### Setup

#### Use Cases for *PharmacoGx*

*Downloading Data from [orcestra.ca](https://orcestra.ca)*
```{r get_avail_psets}
available <- PharmacoGx::availablePSets() |>
  data.table::as.data.table()

print(names(available))

print(available[, c("Dataset Name", "PSet Name", "version")])
```

The following function from [*PharmacoGx*](https://bioconductor.org/packages/3.19/PharmacoGx) can be used to download any of the available PSets from [orcestra.ca](https://orcestra.ca).

The command to do so is:
``` {r download_pset_orcestra, eval=FALSE}
PharmacoGx::downloadPSet(
  name = "CCLE_2015",
  saveDir = "../psets", # change this directory as you see fit
  timeout = 3600,
  verbose = TRUE
)

# Note: this may take a while to download as the files are stored in
# Zenodo and are quite large
```

For convenience and in the interest of time, we have created a `PharmacoSet` to be used in this tutorial. We will be interacting with this dataset for the remainder of the tutorial.
```{r load_pset}
pset <- CBWWorkshop2024::dummy_pset
pset
```

### Understanding the `PharmacoSet` Data Structure

The `PharmacoSet` class is a container for pharmacogenomic data.

This pharmacogenomic data is typically generated from high-throughput screening experiments where cell lines are treated with a panel of drugs at multiple doses and the response is measured using a molecular assay.

Pharmacogenomic data is located in a `PharmacoSet` within its slots, which are accessed using the `@` operator.
```{r show_pset_structure}
slotNames(pset)
```

![PharmacoSet class structure](./img/coreset-class.png)
### Metadata 

Metadata for cell-lines (`samples`) and drugs (`treatments`) are stored in the `sample` and `treatment` slots, respectively.

These are data frames with rows corresponding to samples or treatments and columns corresponding to metadata fields. The metadata fields are typically a combination of data from the original data source, and curated data from external sources such as [Cellosaurus](https://web.expasy.org/cellosaurus/),[DrugBank](https://go.drugbank.com/), and [PubChem](https://pubchem.ncbi.nlm.nih.gov/).

#### View the `sample` slot

We can access the `sampleNames` of the `PharmacoSet`:
```{r show_sample_names}
PharmacoGx::sampleNames(pset)
```

To get all the metadata associated with the samples, we can access the `sample` slot:
```{r show_samples}
pset@sample |> str()
```

We can see from the `sample` slot that there are 50 samples in this `PharmacoSet`.

#### View the `treatment` slot

Similar to the `sample`, we can access the `treatmentNames` of the `PharmacoSet`:
```{r show_treatment_names}
PharmacoGx::treatmentNames(pset) |> head()
```

To get all the metadata associated with the treatments, we can access the `treatment` slot:
```{r show_treatments}
pset@treatment |> str()
```

There are also 22 treatments used.

### Molecular Profiles

In `r PGx`, molecular profiles refer to any data that is measured on the samples in the `PharmacoSet`. This can include gene expression, copy number, mutation, or any other type of data that can be measured on a sample.

Each Molecular Data Type (`mDataType`) is stored in a `SummarizedExperiment`. All the `SummarizedExperiment` objects are stored in a container called a `MultiAssayExperiment` which can be accessed through the `molecularProfiles` slot.

#### `MultiAssayExperiment` and `SummarizedExperiment`
![Summarized Experiment and Multi Assay Experiment classes](./img/multiassayexperiment_summarizedexperiment_schematics.png)
#### View the `molecularProfiles` Slot

```{r show_molecular_profiles}
pset@molecularProfiles
```

### Treatment Response

The treatment response data was traditionally stored in a `list`. To accelerate analysis, we have developed a new class called the `TreatmentResponseExperiment` (TRE) which has been specifically designed to handle high dimensional biological stimulus-response data.

#### View the `treatmentResponse` slot

```{r show_treatment_response}
pset@treatmentResponse
```

To view all the methods available for the `TreatmentResponseExperiment` class, we can use the `methods` function:
```{r show_tre_methods}
methods(class = "TreatmentResponseExperiment")
```

### Subsetting a `PharmacoSet`

#### Subset by `sampleNames` and/or `treatmentNames`

When subsetting a `PharmacoSet` object by `sample` names, both the `MultiAssayExperiment` and `TreatmentResponseExperiment` objects will be subsetted so all their internal `Experiments` only contain data for the samples of interest.

However, when subsetting by `treatment` names, only the `TRE` object will be subsetted.
```{r subset_pset}
PharmacoGx::subsetBySample(
  pset,
  sample = PharmacoGx::sampleNames(pset)[1:5]
)

PharmacoGx::subsetByTreatment(
  pset,
  treatment = PharmacoGx::treatmentNames(pset)[1:5]
)
```

#### Subsetting Using `sample` and `treatment` Metadata

The utility of the `metadata` slots in the `PharmacoSet` class.
```{r subset_pset_metadata, warning=FALSE}
unique(pset@sample$tissueid)

tissues_of_interest <- c("Kidney")

(samples_of_interest <- pset@sample[
  pset@sample$tissueid %in% tissues_of_interest,
  "sampleid"
]
)

PharmacoGx::subsetBySample(
  pset,
  samples_of_interest
)
```

A concise way to subset by `sample` in one step:
```{r subset_pset_metadata2, warning=FALSE}
PharmacoGx::subsetBySample(
  pset,
  sample = pset@sample[
    pset@sample$tissueid == "Kidney",
    "sampleid"
  ]
)
```

### Computing Over a `TreatmentResponseExperiment`

The `TreatmentResponseExperiment` class has been designed to facilitate more than just storing data efficiently. Once the data is curated and stored safely inside our object, we are ready to start answering questions.

First, let's extract the `TRE` to work with:
```{r extract_tre}
tre <- pset@treatmentResponse
show(tre)
```

#### Aggregating Over the `TreatmentResponseExperiment`

The `aggregate` function is a powerful tool that allows us to summarize the data in a `TreatmentResponseExperiment` object.
```{r tre_aggregate_example}
tre |>
  aggregate(
    assay = "sensitivity",
    N = .N,
    by = c("treatmentid", "treatmentdose", "sampleid", "bio_rep")
  )
```

You can also use the `subset` function to subset the `TreatmentResponseExperiment` object before performing `aggregate`.

Additionally, you can even `subset` over the result of an `aggregate` operation.
```{r tre_aggregate_example2}
tre |>
  subset(treatmentid %in% c("Doxorubicin", "Ixabepilone")) |>
  aggregate(
    assay = "sensitivity",
    N = .N,
    by = c("treatmentid", "treatmentdose", "sampleid", "bio_rep")
  ) |>
  subset(N > 1 & sampleid == "A-498")
```

##### Plotting the Number of Replicates

The last two examples have shown that there are technical replicates in the data.
We can visualize the number of replicates using a histogram.
```{r tre_aggregate}
tre |>
  aggregate(
    assay = "sensitivity",
    N = .N,
    by = c("treatmentid", "treatmentdose", "sampleid", "bio_rep")
  ) |>
  with(
    expr = hist(
      N,
      main = "Histogram of Number of Replicates",
      xlab = "Number of Replicates"
    )
  )
```

##### Summarize Over Technical Replicates

Depending on the experiment design, you will need to choose how you want to proceed with the data.

One common approach is to summarize the technical replicates into a single value, this can be done by taking the mean, median, or any other summary statistic.

#### `Endoaggregate`

In the interest of computation time and resources, we want to summarize the technical replicates into a single value and store that result **inside** the `TreatmentResponseExperiment`.

For this, we have developed the `endoaggregate` method. 

This method will perform similar to the `aggregate` method, but will return a `TreatmentResponseExperiment` object with the summarized data as another assay.
```{r tre_endoaggregate}
new_tre <- tre |>
  endoaggregate(
    N = .N,
    assay = "sensitivity",
    target = "tech_rep_counts",
    by = c("treatmentid", "treatmentdose", "sampleid", "bio_rep")
  )
show(new_tre)
head(new_tre$tech_rep_counts[order(-N)])
```

Let's use this method to summarize the technical replicates by taking the mean of the `viability` values for each unique combination of `treatmentid`, `treatmentdose`, `sampleid`, and `bio_rep`.
```{r tre_endoaggregate2}
tre_avged <- tre |>
  endoaggregate(
    viability = mean(viability),
    assay = "sensitivity",
    target = "mean_sensitivity",
    by = c("treatmentid", "treatmentdose", "sampleid", "bio_rep")
  )
str(tre_avged$mean_sensitivity)
```

##### Computing Profiles
```{r tre_endoaggregate3, warning=FALSE}
tre_profiled <- tre_avged |>
  endoaggregate(
    {
      fit <- PharmacoGx::logLogisticRegression(treatmentdose, viability)
      IC50 <- PharmacoGx::computeIC50(treatmentdose, Hill_fit = fit)
      AAC <- PharmacoGx::computeAUC(treatmentdose, Hill_fit = fit, area.type = "Fitted")
      list(
        HS = fit[["HS"]], E_inf = fit[["E_inf"]] / 100, EC50 = fit[["EC50"]],
        Rsq = as.numeric(unlist(attributes(fit))),
        AAC = AAC,
        IC50 = IC50
      )
    },
    assay = "mean_sensitivity",
    subset = treatmentid %in% rowData(tre_avged)[, unique(treatmentid)][1:3],
    by = c("treatmentid", "sampleid", "bio_rep"),
    enlist = FALSE,
    target = "profiles"
  )
```

If we didn't subset the `TRE` this computation will have taken a while since it is a computationally intensive operation and run on a single thread.

Under the hood, the `CoreGx` package performs the aggregation. To speed up computation, it provides an `nthread` parameter to parallelize the computation.

To determine a safe, and optimal number of threads to use, we can use the `CoreGx::optimizeCoreGx` function which will tell us a safe number of threads.

:::: {.callout type="blue" title="Note"}

The following two code chunks will not be evaluated in this vignette as it may take some time.

::::
```{r determine_nthreads, warning=FALSE, eval=FALSE}
CoreGx::optimizeCoreGx(tre_avged)
```

Depending on your device, this number may vary. Let's use a conservative number of threads for this example.
```{r tre_endoaggregate4, warning=FALSE, eval=FALSE}
THREADS <- 6 # github runners provide 2c

tre_profiled <- tre_avged |>
  endoaggregate(
    {
      fit <- PharmacoGx::logLogisticRegression(treatmentdose, viability)
      IC50 <- PharmacoGx::computeIC50(treatmentdose, Hill_fit = fit)
      AAC <- PharmacoGx::computeAUC(treatmentdose, Hill_fit = fit, area.type = "Fitted")
      list(
        HS = fit[["HS"]], E_inf = fit[["E_inf"]] / 100, EC50 = fit[["EC50"]],
        Rsq = as.numeric(unlist(attributes(fit))),
        AAC = AAC,
        IC50 = IC50,
        mindose = min(treatmentdose),
        maxdose = max(treatmentdose),
        numdose = length(unique(treatmentdose)),
        minviability = min(viability),
        maxviability = max(viability)
      )
    },
    assay = "mean_sensitivity",
    by = c("treatmentid", "sampleid", "bio_rep"),
    enlist = FALSE,
    target = "profiles",
    nthread = THREADS
  )
```

Let's look at the profiles we have computed:
```{r tre_profiled}
show(tre_profiled)

tre_profiled$profiles
```

### Quality Control of Pharmacogenomic Datasets

For the remainder of the lab, we will go over some quick case scenarios that require
quality control. We will load in new molecular profile.

#### Checking for Missing Values
```{r get_batch_tpm_2}
# get molecular profile
tpm_matrix <- pset@molecularProfiles[["rnaseq.tpm.batch"]] |> assay() |> as.data.frame()
tpm_matrix[1:5,1:5]

# get metadata
meta <- pset@molecularProfiles[["rnaseq.tpm.batch"]] |> colData()
meta |> head()
```

For this exercise, we purposely put in a gene with many missing values. Let's look for this gene.

The code below will quantify the number of `NA` values in each row (gene).
```{r count_NA_2}
apply(tpm_matrix, 1, function(x) sum(is.na(x))) |> head() 


# tre_profiled$profiles

# TODO: add code to make box plots for AAC and IC50 per drug
```

```{r}
# print only genes with NA values
sum_NA <- apply(tpm_matrix, 1, function(x) sum(is.na(x)))
sum_NA[sum_NA > 0]
```

We see that `GENE002` has 25 `NA` values. It is important to consider the proportion of `NA` values relative to the number of observations. We can quickly calculate the proportion:
```{r prortion_NA}
num_NA <- sum_NA[sum_NA > 0] |> unname()
num_observations <- ncol(tpm_matrix)

# get proportion
num_NA / num_observations
```

Now we know that 50% of samples have an `NA` value rather than an expression level for `GENE002`. This can be indicative of some technical issue. Let's remove this gene from downstream analysis.
```{r remove_gene}
tpm_matrix <- tpm_matrix[-which(rownames(tpm_matrix) == "GENE002"), ]
any(is.na(tpm_matrix))
```

In the last line of code, we check if there were any remaining `NA` values. Since there are none, we can move on to visualizing our data.

#### Principal Component Analysis for Outlier Removal

Let's quickly take a look at our expression matrix again.
```{r view_tpm}
tpm_matrix[1:5, 1:5]
```

The expression matrix is currently formatted such that the features (genes) are the rows and the samples (cells) are the columns. 

Since we want to do PCA to visualize the *samples*, we need to transpose the matrix so that the attributes of the samples (genes) are the columns instead.
```{r transpose_matrix}
t_tpm_matrix <- tpm_matrix |>
  t() |>
  as.data.frame()
t_tpm_matrix[1:5, 1:5]
```

Once the expression matrix is in the correct format, we can perform PCA using the 
`prcomp` function.
```{r pca_batch}
org_pca <- prcomp(t_tpm_matrix)$x |> as.data.frame()

print(dim(org_pca))

org_pca[1:5, 1:5]
```

To visualize the data, we plot the first two principal components (PCs).
```{r plot_PCs_batch}
# add batch labels
org_pca$Batch <- meta$batchid[match(rownames(org_pca), meta$sampleid)] |> as.factor()

# plot
p1 <- ggplot(org_pca) +
  geom_point(aes(x = PC1, y = PC2, color = Batch), size = 5) +
  scale_color_manual(values = c("#624763", "#B1D3A3")) +
  theme_classic() +
  ggtitle("Before Batch Correction")
p1
```

There is a very obvious outlier in our data. We can quantitatively identify this outlier by identifying samples that lie beyond a threshold of `1.5 * IQR` of the first and fourth quartiles.
```{r identify_outliers}
# extract PC scores for given PC
scores <- org_pca[["PC1"]]

# compute IQR of given PC
iqr <- IQR(scores)

# compute upper and lower thresholds
upp_thres <- quantile(scores, 0.75) + 1.5 * iqr
low_thres <- quantile(scores, 0.25) - 1.5 * iqr

# print samples with values beyond threshold
outlier <- rownames(org_pca)[which(scores < low_thres | scores > upp_thres)]
paste("Outlier for PC1:", outlier) |> print()
```

Let's remove `T-47D` and re-plot our data.
```{r rm_outliers}
# remove outlier
outlier <- "T-47D"
tpm_matrix[[outlier]] <- NULL

# redo PCA and plotting
org_pca <- prcomp(t(tpm_matrix))$x |> as.data.frame()
org_pca$Batch <- meta$batchid[match(rownames(org_pca), meta$sampleid)] |> as.factor()

p1 <- ggplot(org_pca) +
  geom_point(aes(x = PC1, y = PC2, color = Batch), size = 5) +
  scale_color_manual(values = c("#624763", "#B1D3A3")) +
  theme_classic() +
  ggtitle("Before Batch Correction")

p1
```

Now that the outlier is removed, we have a better visualization of the data. It is very evident that the data points (samples) tend to cluster by batch. This is indicative of a potential batch effect.

#### Adjusting for Known Batches

When we have a known batch, we can adjust for it directly. One method is to use the `ComBat()` function from the `sva` package.
```{r adjust_known_batch}
# adjust for known batch
adj_tpm_matrix <- ComBat(
  dat = tpm_matrix,
  batch = as.factor(meta$batchid[match(colnames(tpm_matrix), meta$sampleid)]),
  par.prior = TRUE,
  prior.plots = FALSE
)

adj_tpm_matrix[1:5, 1:5]
```

We can now perform PCA and visualize on our adjusted TPM counts matrix. We will compare the results to the original PCA visualization.

Don't forget to transpose the adjusted counts matrix!
```{r pca_adj_batch}
# perform PCA on adjusted matrix

adj_pca <- prcomp(t(adj_tpm_matrix))$x |> as.data.frame()
adj_pca$Batch <- meta$batchid[match(rownames(adj_pca), meta$sampleid)] |> as.factor()

# create scatter plot
p2 <- ggplot(adj_pca) +
  geom_point(aes(x = PC1, y = PC2, color = Batch), size = 5) +
  scale_color_manual(values = c("#624763", "#B1D3A3")) +
  theme_classic() +
  ggtitle("After Batch Correction")

# plot both plots side by side for comparison
ggarrange(p1, p2, ncol = 2)
```

For downstream pharmacogenomic analysis (or any other bioinformatic analysis), the batch-corrected expression matrix should be used.

For downstream pharmacogenomic analysis (or any other bioinformatic analysis), the batch-corrected expression matrix should be used.

:::: {.callout type="green" title="Lab Completed!"}

Congratulations! You have completed Lab 2!

::::
