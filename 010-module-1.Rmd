# (PART) Modules {-}

# Module 1: Intro to Pharmacogenomics in the Context of Cancer

## Lecture

<iframe width="640" height="360" src="https://www.youtube.com/embed/12axQFiDtiQ?si=BV_38viIvXxDQDv_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

<br>

<iframe src="https://drive.google.com/file/d/1FrUBL7m8o_5EBT3nnsgMykGoNMCNuLhw/preview" width="640" height="480" allow="autoplay"></iframe>

## Lab

```{r, message=FALSE} 
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, message=FALSE}
PGx <- BiocStyle::Biocpkg("PharmacoGx")
CGx <- BiocStyle::Biocpkg("CoreGx")
TGx <- BiocStyle::Biocpkg("ToxicoGx")
RGx <- BiocStyle::Biocpkg("RadioGx")
Xv <- BiocStyle::Biocpkg("Xeva")
DT <- BiocStyle::CRANpkg("data.table")
SE <- BiocStyle::Biocpkg("SummarizedExperiment")
MAE <- BiocStyle::Biocpkg("MultiAssayExperiment")
```

### Overview 

#### Instructor(s) Name(s) and Contact Information

* Jermiah Joseph <jermiah.joseph@uhn.ca>
* Nikta Feizi <nikta.feizi@uhn.ca>
* Julia Nguyen <julia.nguyen@uhn.ca>

##### Lab Description

##### Learning Goals

* Understand the data structure of a PharmacoSet
* Learn how to access features and metadata from a PharmacoSet
* Learn how to design linear multivariate predictors
* Learn how to filter out outliers and missing values

##### Learning Objectives

* Describe the use cases for [*PharmacoGx*](https://bioconductor.org/packages/3.19/PharmacoGx) in Pharmacogenomics
* Understand the structure of the `CoreSet` and `PharmacoSet` classes to facilitate their use in subsequent analyses
* Download/load a `PharmacoSet` using [*PharmacoGx*](https://bioconductor.org/packages/3.19/PharmacoGx) or [orcestra.ca](https://orcestra.ca)
* Subset and filter a `PharmacoSet` by samples and/or treatments
* Access the molecular features, dose-response, and metadata contained within the `PharmacoSet`

```{r global_knitr_opts, echo=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  include = TRUE,
  warning = FALSE,
  message = TRUE
)
```

```{r load_packages, eval=TRUE, echo=FALSE, include=FALSE}
suppressPackageStartupMessages({
  library(CBWWorkshop2024)
  library(PharmacoGx)
  library(data.table)
  library(reshape2)
})
```

### Getting Started

#### Exploring Preclinical Datasets for Pharmacogenomic Analysis

*See list of available subsetted datasets from [Reference](https://bhklab.github.io/CBWWorkshop2024/reference/index.html)

##### Molecular Profiles

We will start with RNA-Seq data as a simple example. 

```{r, get_rnaseq}
data(GDSC_rnaseq)
GDSC_rnaseq |> head()
```

Few key things to notice here: there are identifiers for the sample (`model_id`, `model_name`), identifiers for the gene (`gene_id`, `gene_symbol`), as well as two expression values (`read_count`, `fpkm`).

When we create our expression matrices, we will select one sample identifier, one feature (gene) identifier, and one expression value.

##### Metadata/annotation Files

When preparing for pharmacogenomic analysis, it is ideal to have accompanying metadata for both the samples (cell lines) and the features (genes).

We have made this data available through the package as well. We'll start with the gene annotations:
```{r get_gene_ids}
data(GDSC_gene_identifiers)
GDSC_gene_identifiers |> head()
```

The data above has been provided by GDSC and enables mapping across various gene annotations. It is important to identify which gene annotation maps to the RNA-Seq data and to check for completeness.
```{r check_gene_ids}
GDSC_rnaseq$gene_id %in% GDSC_gene_identifiers$gene_id |> table()

GDSC_rnaseq$gene_symbol %in% GDSC_gene_identifiers$hgnc_symbol |> table()

GDSC_rnaseq$gene_symbol %in% GDSC_gene_identifiers$cosmic_gene_symbol |> table()
```

We can see that `gene_id` maps completely to the genes in our RNA-seq data, whereas `hgnc_symbol` and `cosmic_gene_symbol` are missing gene symbols (see the numbers under `FALSE`). This is a pretty obvious indicator to move forward with the `gene_id` for downstream analysis.

Now we move over to the cell line annotations. There are a few attributes made available, we first look to confirm the mapping id to the RNA-Seq data.
```{r get_model_list}
data(GDSC_model_list)
print(colnames(GDSC_model_list))

GDSC_rnaseq$model_id %in% GDSC_model_list$model_id |> table()
```

Below are some examples of other available variables that may be of interest for downstream analysis. 
```{r get_model_traits}
GDSC_model_list[, c("model_id", "model_name", "tissue", "ploidy_wes", "mutational_burden", "gender", "ethnicity")] |> head()
```

##### Drug Response Data 

Finally, we'll load in the corresponding drug response data for these cell lines.
```{r get_drug_response}
data(GDSC_drug_response)
GDSC_drug_response |> head()

unique(GDSC_rnaseq$model_id) %in% GDSC_drug_response$SANGER_MODEL_ID |> table()
```

We can use `SANGER_MODEL_ID` to map back to our RNA-Seq data. `DRUG_NAME` will be used as the identifier for the treatment. We also have both the IC50 (`LN_IC50`) and the AUC (`AUC`) values for each cell-drug pair.

Notice that some of the cell lines do not have drug response data. These will need to be filtered before downstream analysis.

#### Exploring Other Multi-omic Profiles
We have prepared a variety of other molecular profiles from both GDSC and CCLE. We look through a few more examples below to better understand these data types.

##### Driver Mutations 

Load in the driver mutations data from GDSC:
```{r get_driver_mutations}
data(GDSC_drivers)
GDSC_drivers |> head()
```

Notice that this data is not a continuous expression like the RNA-Seq. This data 
will have to be further processed before it can be used to predict response.

##### Methylation

Load in the methylation matrix from GDSC:
```{r get_methylation}
data(GDSC_methylation)
GDSC_methylation[1:5, 1:5]
```

This data has already been processed into a matrix. Notice though that the sample names are not present, instead there is the array ID and position. We can use the provided annotation file to map back to the sample names in our model list.
```{r get_methylation_model_list}
data(GDSC_methylation_model_list)
GDSC_methylation_model_list |> head()

GDSC_methylation_model_list$sampleid <- paste0(
  "X", GDSC_methylation_model_list$Sentrix_ID,
  "_", GDSC_methylation_model_list$Sentrix_Position
)
colnames(GDSC_methylation) %in% GDSC_methylation_model_list$sampleid |> table()

colnames(GDSC_methylation) <- GDSC_methylation_model_list$Sample_Name[
  match(colnames(GDSC_methylation), GDSC_methylation_model_list$sampleid)
]
GDSC_methylation[1:5, 1:5]
```

We have provided a few other subsetted datasets. A full list is available from [Reference](https://bhklab.github.io/CBWWorkshop2024/reference/index.html).

We encourage independent exploration of these datasets.

#### Creating Expression Matrices for Pharmacogenomic Analysis

To facilitate downstream pharmacogenomic analysis, we want to create an expression matrix such that:

* Features are the rows
* Samples are the columns
* Feature expression as the individual values

Below, we show a example of such matrix using dummy data.
```{r example_expr_matrix}
dummy_data <- setNames(
  as.data.frame(replicate(5, rnorm(5))),
  paste0("Sample", 1:5)
)
rownames(dummy_data) <- paste0("Feature", 1:5)
dummy_data
```

Let's revisit the RNA-Seq example. The data is currently in a long format (i.e. there is one row for each sample-feature observation). 
```{r get_rnaseq2}
GDSC_rnaseq |> head()
GDSC_rnaseq |> dim()

# number of cell line samples
length(unique(GDSC_rnaseq$model_id))

# number of genes
length(unique(GDSC_rnaseq$gene_id))
```

We want to convert this into a wide format such that each row is a gene, each column is a sample, and the values are the gene expression.
```{r dcast_rna}
expr <- reshape2::dcast(GDSC_rnaseq, gene_id ~ model_name, value.var = "fpkm")
rownames(expr) <- expr$gene_id
expr$gene_id <- NULL

expr[1:5, 1:10]

expr |> dim()
```

Notice that we have the 1350 genes as the rows and the 100 cell lines as the columns.

#### Feature Extraction Techniques to Define Biomarkers

While using the continuous expression of single features is a convenient method for quantifying biomarkers, there are cases when other techniques are needed and/or are more appropriate.

##### Binarization

Recall that the driver mutations data was not presented as continuous numeric values. One method to prepare this data is to binarize the mutation status.
```{r get_driver_mutations2}
GDSC_drivers |> head()
```

Looking at the first row, we can see that there is a mutation on the `RGPD3` gene in the `SIDM02101` cell line model. We would represent such mutation events with `1`.

The code below again casts the long data frame into a wide format. This time we specify an aggregate function `length()`, which returns the number of rows (mutation events) for each gene-cell line pair. This was done by passing the option `fun.aggregate = length`.
```{r process_driver_mutations}
expr <- reshape2::dcast(
  GDSC_drivers,
  gene_symbol ~ model_id,
  value.var = "cdna_mutation",
  fun.aggregate = length
)
rownames(expr) <- expr$gene_symbol
expr$gene_symbol <- NULL

expr["RGPD3", "SIDM02101"]

expr[1:5, 1:10]
```

There was one mutation event on the `RGPD3` gene in the `SIDM02101` cell line model, hence the value of this combination is `1`.

Mutation events are relatively sparse, so we see `0` for the majority of the matrix.

##### Signature extraction

There are cases when individual features have low predictive power, but when combined become much more informative of drug response.

Let's revisit our methylation data. Recall that each row is a CpG site. There are 1000 CpG sites.
```{r get_methylation2}
GDSC_methylation[1:5, 1:5]

GDSC_methylation |> dim()
```

Signatures refer to combinations of features that form some pattern with biological relevance. For example, you may choose to define a signature X to represent CpG sites located on promoters of genes involved in pathway Y.

For simplicity, we can define some arbituary signatures from our CpG sites.
```{r define_signatures}
set.seed(123)
signatures <- data.frame(
  CpG = rownames(GDSC_methylation),
  Signature = sample(gl(10, 100, length = 1000))
)
signatures |> head()
```

Each of the 1000 CpG sites was randomly assigned to one of 10 signatures.

Next we want to quantify the signature for each cell line. Again, for simplicity, we will sum the beta values across each CpG for each signature.
```{r quantify_signatures}
sScores <- data.frame(matrix(NA, nrow = 0, ncol = 100))

for (s in c(1:10)) {
  # get CpGs within each signature
  cpgs <- signatures[signatures$Signature == s, ]$CpG
  mSig <- GDSC_methylation[rownames(GDSC_methylation) %in% cpgs, ]

  # compute sum of beta values for each cell line
  sSum <- colSums(mSig)
  sScores <- rbind(sScores, sSum)
}

rownames(sScores) <- paste0("Signature", 1:10)
colnames(sScores) <- colnames(GDSC_methylation)

sScores[1:10, 1:5]
```

We now have a new expression matrix, this time of the 10 defined signatures for each of our cell lines.

#### Individual Practice

For the remainder of this session, we provide more sample datasets to practice the above techniques.

* [CCLE_chromatin.rda](./content-files/downloads/CCLE_chromatin.rda)
* [CCLE_metabolomics.rda](./content-files/downloads/CCLE_metabolomics.rda)
* [CCLE_model_list.rda](./content-files/downloads/CCLE_model_list.rda)
* [CCLE_rrpa.rda](./content-files/downloads/CCLE_rrpa.rda)

:::: {.callout type="green" title="Lab Completed!"}

Congratulations! You have completed Lab 1!

::::
