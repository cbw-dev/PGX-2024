[["index.html", "Pharmacogenomics Data Analysis 2024 Workshop Info Class Photo Schedule Pre-work", " Pharmacogenomics Data Analysis 2024 Faculty: Benjamin Haibe-Kains, Jermiah Joseph, Nikta Feizi, Julia Nguyen, and Nia Hughes October 17, 2024 - October 18, 2024 Workshop Info Welcome to the 2024 Pharmacogenomics Data Analysis Canadian Bioinformatics Workshop webpage! Class Photo Schedule Time (EDT) October 17 Time (EDT) October 18 8:30 Arrivals &amp; Check-in 8:30 Arrivals 9:00 Welcome (Nia Hughes) 9:00 Module 3: Pharmacogenomics for biomarker discovery - Basic analysis (Nikta, Julia) 9:30 Module 1: Introduction to pharmacogenomics in the context of cancer (Benjamin) 10:00 Break (30 mins) 10:30 Break (30 mins) 10:30 Module 3 Lab: Statistical analysis - Part 1 Lab (Nikta, Julia) 11:00 Module 1 Lab: Getting to know multi-omics data (Julia, Nikta, Jermiah) 12:30 Class photo + Lunch (1 hr) 13:00 Lunch (1 hr) 13:30 Module 4: Pharmacogenomics for biomarker discovery - Advanced analysis (Nikta, Julia) 14:00 Module 2: Data preparation for pharmacogenomic analysis (Jermiah) 14:30 Break (30 mins) 15:00 Break (30 mins) 15:00 Module 4 Lab: Statistical analysis - Part 2 (Nikta, Julia) 15:30 Module 2 Lab: Hands-on with pharmacogenomics data (Jermiah, Almas) 17:00 Survey &amp; Closing Remarks 17:30 Finished 17:30 Finished Pre-work You can find your pre-work here. "],["data-and-compute-setup.html", "Data and Compute Setup", " Data and Compute Setup Course Data Downloads CCLE_chromatin.rda CCLE_metabolomics.rda CCLE_model_list.rda CCLE_rrpa.rda dummy_pset.rda GDSC_drivers.rda GDSC_drug_response.rda GDSC_gene_identifiers.rda GDSC_methylation_model_list.rda GDSC_methylation.rda GDSC_model_list.rda GDSC_rnaseq.rda NCI_ALMANAC_pset.rda NCI_ALMANAC_raw.rda NCI_ALMANAC_sample_metadata.rda NCI_ALMANAC_TRE.rda NCI_ALMANAC_treatment_metadata.rda NCI60_molecular_data.rda Compute Setup Installing from GitHub Run to install this package and its dependencies. pak::pkg_install(&quot;bhklab/CBWWorkshop2024&quot;, dependencies=TRUE) ## ! Using bundled GitHub PAT. Please add your own PAT using `gitcreds::gitcreds_set()`. ## ℹ Loading metadata database✔ Loading metadata database ... done ## ## ℹ No downloads are needed ## ✔ 1 pkg + 204 deps: kept 186 [8.5s] Note You may need to install the pak package first. pak is a “Fresh Approach to R Package Installation”. You can install it by running: install.packages(&quot;pak&quot;) "],["module-1-intro-to-pharmacogenomics-in-the-context-of-cancer.html", "Module 1: Intro to Pharmacogenomics in the Context of Cancer Lecture Lab", " Module 1: Intro to Pharmacogenomics in the Context of Cancer Lecture Lab knitr::opts_chunk$set( collapse = TRUE, comment = &quot;#&gt;&quot; ) PGx &lt;- BiocStyle::Biocpkg(&quot;PharmacoGx&quot;) CGx &lt;- BiocStyle::Biocpkg(&quot;CoreGx&quot;) TGx &lt;- BiocStyle::Biocpkg(&quot;ToxicoGx&quot;) RGx &lt;- BiocStyle::Biocpkg(&quot;RadioGx&quot;) Xv &lt;- BiocStyle::Biocpkg(&quot;Xeva&quot;) DT &lt;- BiocStyle::CRANpkg(&quot;data.table&quot;) SE &lt;- BiocStyle::Biocpkg(&quot;SummarizedExperiment&quot;) MAE &lt;- BiocStyle::Biocpkg(&quot;MultiAssayExperiment&quot;) Overview Instructor(s) Name(s) and Contact Information Jermiah Joseph jermiah.joseph@uhn.ca Nikta Feizi nikta.feizi@uhn.ca Julia Nguyen julia.nguyen@uhn.ca Lab Description Learning Goals Understand the data structure of a PharmacoSet Learn how to access features and metadata from a PharmacoSet Learn how to design linear multivariate predictors Learn how to filter out outliers and missing values Learning Objectives Describe the use cases for PharmacoGx in Pharmacogenomics Understand the structure of the CoreSet and PharmacoSet classes to facilitate their use in subsequent analyses Download/load a PharmacoSet using PharmacoGx or orcestra.ca Subset and filter a PharmacoSet by samples and/or treatments Access the molecular features, dose-response, and metadata contained within the PharmacoSet Getting Started Exploring Preclinical Datasets for Pharmacogenomic Analysis *See list of available subsetted datasets from Reference Molecular Profiles We will start with RNA-Seq data as a simple example. data(GDSC_rnaseq) GDSC_rnaseq |&gt; head() #&gt; model_id model_name data_source gene_id gene_symbol read_count fpkm #&gt; 1 SIDM00794 A388 sanger SIDG00082 ABCC6 10 0.01 #&gt; 2 SIDM00794 A388 sanger SIDG00106 ABCF3 20264 25.95 #&gt; 3 SIDM00794 A388 sanger SIDG00108 ABCG2 1070 1.47 #&gt; 4 SIDM00794 A388 sanger SIDG00148 ABI3 6 0.02 #&gt; 5 SIDM00794 A388 sanger SIDG00177 ACADSB 1410 1.50 #&gt; 6 SIDM00794 A388 sanger SIDG00198 ACER1 12 0.06 Few key things to notice here: there are identifiers for the sample (model_id, model_name), identifiers for the gene (gene_id, gene_symbol), as well as two expression values (read_count, fpkm). When we create our expression matrices, we will select one sample identifier, one feature (gene) identifier, and one expression value. Metadata/annotation Files When preparing for pharmacogenomic analysis, it is ideal to have accompanying metadata for both the samples (cell lines) and the features (genes). We have made this data available through the package as well. We’ll start with the gene annotations: data(GDSC_gene_identifiers) GDSC_gene_identifiers |&gt; head() #&gt; gene_id cosmic_gene_symbol ensembl_gene_id entrez_id hgnc_id hgnc_symbol #&gt; 1 SIDG00001 A1BG ENSG00000121410 1 HGNC:5 A1BG #&gt; 2 SIDG00002 ENSG00000268895 503538 HGNC:37133 A1BG-AS1 #&gt; 3 SIDG00003 A1CF ENSG00000148584 29974 HGNC:24086 A1CF #&gt; 4 SIDG00004 A2M ENSG00000175899 2 HGNC:7 A2M #&gt; 5 SIDG00005 ENSG00000245105 144571 HGNC:27057 A2M-AS1 #&gt; 6 SIDG00006 A2ML1 ENSG00000166535 144568 HGNC:23336 A2ML1 #&gt; refseq_id uniprot_id #&gt; 1 NM_130786 P04217 #&gt; 2 NR_015380 #&gt; 3 NM_014576 Q9NQ94 #&gt; 4 NM_000014 P01023 #&gt; 5 NR_026971 #&gt; 6 NM_144670 A8K2U0 The data above has been provided by GDSC and enables mapping across various gene annotations. It is important to identify which gene annotation maps to the RNA-Seq data and to check for completeness. GDSC_rnaseq$gene_id %in% GDSC_gene_identifiers$gene_id |&gt; table() #&gt; #&gt; TRUE #&gt; 135000 GDSC_rnaseq$gene_symbol %in% GDSC_gene_identifiers$hgnc_symbol |&gt; table() #&gt; #&gt; FALSE TRUE #&gt; 2100 132900 GDSC_rnaseq$gene_symbol %in% GDSC_gene_identifiers$cosmic_gene_symbol |&gt; table() #&gt; #&gt; FALSE TRUE #&gt; 69600 65400 We can see that gene_id maps completely to the genes in our RNA-seq data, whereas hgnc_symbol and cosmic_gene_symbol are missing gene symbols (see the numbers under FALSE). This is a pretty obvious indicator to move forward with the gene_id for downstream analysis. Now we move over to the cell line annotations. There are a few attributes made available, we first look to confirm the mapping id to the RNA-Seq data. data(GDSC_model_list) print(colnames(GDSC_model_list)) #&gt; [1] &quot;model_id&quot; #&gt; [2] &quot;sample_id&quot; #&gt; [3] &quot;patient_id&quot; #&gt; [4] &quot;parent_id&quot; #&gt; [5] &quot;model_name&quot; #&gt; [6] &quot;synonyms&quot; #&gt; [7] &quot;tissue&quot; #&gt; [8] &quot;cancer_type&quot; #&gt; [9] &quot;cancer_type_ncit_id&quot; #&gt; [10] &quot;tissue_status&quot; #&gt; [11] &quot;sample_site&quot; #&gt; [12] &quot;cancer_type_detail&quot; #&gt; [13] &quot;model_type&quot; #&gt; [14] &quot;growth_properties&quot; #&gt; [15] &quot;model_treatment&quot; #&gt; [16] &quot;sampling_day&quot; #&gt; [17] &quot;sampling_month&quot; #&gt; [18] &quot;sampling_year&quot; #&gt; [19] &quot;doi&quot; #&gt; [20] &quot;pmed&quot; #&gt; [21] &quot;msi_status&quot; #&gt; [22] &quot;ploidy_snp6&quot; #&gt; [23] &quot;ploidy_wes&quot; #&gt; [24] &quot;ploidy_wgs&quot; #&gt; [25] &quot;mutational_burden&quot; #&gt; [26] &quot;model_comments&quot; #&gt; [27] &quot;model_relations_comment&quot; #&gt; [28] &quot;COSMIC_ID&quot; #&gt; [29] &quot;BROAD_ID&quot; #&gt; [30] &quot;CCLE_ID&quot; #&gt; [31] &quot;RRID&quot; #&gt; [32] &quot;HCMI&quot; #&gt; [33] &quot;suppliers&quot; #&gt; [34] &quot;supplier&quot; #&gt; [35] &quot;cat_number&quot; #&gt; [36] &quot;species&quot; #&gt; [37] &quot;gender&quot; #&gt; [38] &quot;ethnicity&quot; #&gt; [39] &quot;age_at_sampling&quot; #&gt; [40] &quot;family_history_of_cancer&quot; #&gt; [41] &quot;prior_same_malignancy&quot; #&gt; [42] &quot;prior_other_malignancy&quot; #&gt; [43] &quot;smoking_status&quot; #&gt; [44] &quot;alcohol_exposure_intensity&quot; #&gt; [45] &quot;alcohol_consumption_per_week&quot; #&gt; [46] &quot;history_diabetes&quot; #&gt; [47] &quot;diabetes_treatment&quot; #&gt; [48] &quot;colorectal_cancer_risk_factors&quot; #&gt; [49] &quot;patient_history_of_gastrointestinal_disorder&quot; #&gt; [50] &quot;gastrointestinal_disorder_diagnosed&quot; #&gt; [51] &quot;prior_synchronous_colon_rectal_tumours&quot; #&gt; [52] &quot;history_prior_colon_polyps&quot; #&gt; [53] &quot;previous_current_barretts_oesophagus&quot; #&gt; [54] &quot;reflux_disease_prior&quot; #&gt; [55] &quot;reflux_disease_treatment&quot; #&gt; [56] &quot;h_pylori_infection&quot; #&gt; [57] &quot;history_clinical_chronic_pancreatitis&quot; #&gt; [58] &quot;tumour_grade&quot; #&gt; [59] &quot;tnm_integrated&quot; #&gt; [60] &quot;tnm_t&quot; #&gt; [61] &quot;tnm_n&quot; #&gt; [62] &quot;tnm_m&quot; #&gt; [63] &quot;clinical_staging&quot; #&gt; [64] &quot;metastasis_at_diagnosis&quot; #&gt; [65] &quot;metastatic_site_at_diagnosis&quot; #&gt; [66] &quot;method_procurement&quot; #&gt; [67] &quot;sample_treatment&quot; #&gt; [68] &quot;sample_treatment_details&quot; #&gt; [69] &quot;radiation_type&quot; #&gt; [70] &quot;prior_therapy_outcome&quot; #&gt; [71] &quot;tumour_regression_score&quot; #&gt; [72] &quot;colon_polyps_present_at_time_of_tissue_collection&quot; #&gt; [73] &quot;venous_invasion_present&quot; #&gt; [74] &quot;venous_invasion_type&quot; #&gt; [75] &quot;lymphatic_invasion_present&quot; #&gt; [76] &quot;perineural_invasion_present&quot; #&gt; [77] &quot;gastric_oesophageal_junction&quot; #&gt; [78] &quot;barretts_goblet_cells_present&quot; #&gt; [79] &quot;oesophageal_columnar_metaplasia&quot; #&gt; [80] &quot;goblet_cells_oesophageal_columnar_mucosa&quot; #&gt; [81] &quot;degree_of_dysplasia_non_cancerous_oesophageal_columnar_mucosa&quot; #&gt; [82] &quot;peripancreatic_lymph_nodes_tested_surgery&quot; #&gt; [83] &quot;number_positive_peripancreatic_lymph_nodes&quot; #&gt; [84] &quot;mlh1_expression_by_ihc&quot; #&gt; [85] &quot;mlh1_promoter_methylation_status&quot; #&gt; [86] &quot;msh2_expression_by_ihc&quot; #&gt; [87] &quot;pms2_expression_by_ihc&quot; #&gt; [88] &quot;msh6_expression_by_ihc&quot; #&gt; [89] &quot;braf_mutation_identified&quot; #&gt; [90] &quot;braf_expression_by_ihc&quot; #&gt; [91] &quot;pik3ca_mutation_identified&quot; #&gt; [92] &quot;pten_expression_by_ihc&quot; #&gt; [93] &quot;pten_mutation_identified&quot; #&gt; [94] &quot;kras_mutation_identified&quot; #&gt; [95] &quot;mismatch_repair_status&quot; #&gt; [96] &quot;preoperative_ce_alevel&quot; #&gt; [97] &quot;crispr_ko_data&quot; GDSC_rnaseq$model_id %in% GDSC_model_list$model_id |&gt; table() #&gt; #&gt; TRUE #&gt; 135000 Below are some examples of other available variables that may be of interest for downstream analysis. GDSC_model_list[, c(&quot;model_id&quot;, &quot;model_name&quot;, &quot;tissue&quot;, &quot;ploidy_wes&quot;, &quot;mutational_burden&quot;, &quot;gender&quot;, &quot;ethnicity&quot;)] |&gt; head() #&gt; model_id model_name tissue ploidy_wes mutational_burden #&gt; 1 SIDM01774 PK-59 Pancreas 3.510751 24.79 #&gt; 2 SIDM00192 SNU-1033 Large Intestine 2.780367 23.29 #&gt; 3 SIDM01447 SNU-466 Central Nervous System 2.054101 20.58 #&gt; 4 SIDM01554 IST-MES-2 Lung 1.851007 22.92 #&gt; 5 SIDM01689 MUTZ-5 Haematopoietic and Lymphoid 1.941110 28.76 #&gt; 6 SIDM01460 TM-31 Central Nervous System 2.885529 25.89 #&gt; gender ethnicity #&gt; 1 Unknown Unknown #&gt; 2 Female East Asian #&gt; 3 Male Unknown #&gt; 4 Male White #&gt; 5 Male Unknown #&gt; 6 Female East Asian Drug Response Data Finally, we’ll load in the corresponding drug response data for these cell lines. data(GDSC_drug_response) GDSC_drug_response |&gt; head() #&gt; DATASET NLME_RESULT_ID NLME_CURVE_ID COSMIC_ID CELL_LINE_NAME SANGER_MODEL_ID #&gt; 1 GDSC2 343 15946320 683667 PFSK-1 SIDM01132 #&gt; 2 GDSC2 343 15946560 684052 A673 SIDM00848 #&gt; 3 GDSC2 343 15946840 684057 ES5 SIDM00263 #&gt; 4 GDSC2 343 15947099 684059 ES7 SIDM00269 #&gt; 5 GDSC2 343 15947381 684062 EW-11 SIDM00203 #&gt; 6 GDSC2 343 15947663 684072 SK-ES-1 SIDM01111 #&gt; TCGA_DESC DRUG_ID DRUG_NAME PUTATIVE_TARGET PATHWAY_NAME COMPANY_ID #&gt; 1 MB 1017 Olaparib PARP1, PARP2 Genome integrity 1046 #&gt; 2 UNCLASSIFIED 1017 Olaparib PARP1, PARP2 Genome integrity 1046 #&gt; 3 UNCLASSIFIED 1017 Olaparib PARP1, PARP2 Genome integrity 1046 #&gt; 4 UNCLASSIFIED 1017 Olaparib PARP1, PARP2 Genome integrity 1046 #&gt; 5 UNCLASSIFIED 1017 Olaparib PARP1, PARP2 Genome integrity 1046 #&gt; 6 UNCLASSIFIED 1017 Olaparib PARP1, PARP2 Genome integrity 1046 #&gt; WEBRELEASE MIN_CONC MAX_CONC LN_IC50 AUC RMSE Z_SCORE #&gt; 1 Y 0.010005 10 4.488810 0.974081 0.072391 0.201882 #&gt; 2 Y 0.010005 10 1.782152 0.842679 0.068257 -1.881795 #&gt; 3 Y 0.010005 10 2.116072 0.869909 0.070087 -1.624732 #&gt; 4 Y 0.010005 10 1.685857 0.834608 0.092726 -1.955925 #&gt; 5 Y 0.010005 10 2.078938 0.844879 0.114103 -1.653318 #&gt; 6 Y 0.010005 10 0.592900 0.727416 0.081839 -2.797320 unique(GDSC_rnaseq$model_id) %in% GDSC_drug_response$SANGER_MODEL_ID |&gt; table() #&gt; #&gt; FALSE TRUE #&gt; 10 90 We can use SANGER_MODEL_ID to map back to our RNA-Seq data. DRUG_NAME will be used as the identifier for the treatment. We also have both the IC50 (LN_IC50) and the AUC (AUC) values for each cell-drug pair. Notice that some of the cell lines do not have drug response data. These will need to be filtered before downstream analysis. Exploring Other Multi-omic Profiles We have prepared a variety of other molecular profiles from both GDSC and CCLE. We look through a few more examples below to better understand these data types. Driver Mutations Load in the driver mutations data from GDSC: data(GDSC_drivers) GDSC_drivers |&gt; head() #&gt; gene_id gene_symbol model_id protein_mutation rna_mutation #&gt; 1 SIDG27130 RGPD3 SIDM02101 p.N241fs*6 r.809_819delAAUCUUAUGCU #&gt; 2 SIDG08129 ESR1 SIDM02095 p.L15fs*69 r.412_416delACUGC #&gt; 3 SIDG03559 CBLC SIDM02090 p.Q419fs*81 r.1295_1296insc #&gt; 4 SIDG02114 BAP1 SIDM02090 p.C91Y r.402g&gt;a #&gt; 5 SIDG02114 BAP1 SIDM02090 p.N78S r.363a&gt;g #&gt; 6 SIDG36265 SPEN SIDM02089 p.R753fs*53 r.2618_2627delAGGAGGCUUU #&gt; cdna_mutation cancer_driver cancer_predisposition_variant #&gt; 1 c.721_731delAATCTTATGCT True False #&gt; 2 c.42_46delACTGC True False #&gt; 3 c.1253_1254insC True False #&gt; 4 c.272G&gt;A True False #&gt; 5 c.233A&gt;G True False #&gt; 6 c.2257_2266delAGGAGGCTTT True False #&gt; effect vaf coding source model_name #&gt; 1 frameshift 0.2319 True Sanger Mesobank_CellLine-53T #&gt; 2 frameshift 0.4259 True Sanger Mesobank_CellLine-26 #&gt; 3 frameshift 0.5217 True Sanger Mesobank_CellLine-50T #&gt; 4 missense 0.5217 True Sanger Mesobank_CellLine-50T #&gt; 5 missense 0.4595 True Sanger Mesobank_CellLine-50T #&gt; 6 frameshift 0.6333 True Sanger Mesobank_CellLine-45 Notice that this data is not a continuous expression like the RNA-Seq. This data will have to be further processed before it can be used to predict response. Methylation Load in the methylation matrix from GDSC: data(GDSC_methylation) GDSC_methylation[1:5, 1:5] #&gt; X8359018054_R03C01 X8359018053_R04C02 #&gt; chr1:1051178-1052445 0.3733729 0.4144962 #&gt; chr1:109824313-109824526 0.4644322 0.5959816 #&gt; chr1:109825710-109826207 0.1411910 0.1770613 #&gt; chr1:110008962-110010124 0.4143231 0.5317602 #&gt; chr1:110527248-110528026 0.3022454 0.1882153 #&gt; X8221932075_R03C02 X8221924165_R04C02 #&gt; chr1:1051178-1052445 0.2892333 0.3023764 #&gt; chr1:109824313-109824526 0.5048080 0.4594520 #&gt; chr1:109825710-109826207 0.1668371 0.1698714 #&gt; chr1:110008962-110010124 0.5259936 0.4551888 #&gt; chr1:110527248-110528026 0.2679353 0.2989812 #&gt; X7970368131_R04C02 #&gt; chr1:1051178-1052445 0.3880624 #&gt; chr1:109824313-109824526 0.5114854 #&gt; chr1:109825710-109826207 0.1706867 #&gt; chr1:110008962-110010124 0.4740822 #&gt; chr1:110527248-110528026 0.2603969 This data has already been processed into a matrix. Notice though that the sample names are not present, instead there is the array ID and position. We can use the provided annotation file to map back to the sample names in our model list. data(GDSC_methylation_model_list) GDSC_methylation_model_list |&gt; head() #&gt; Sample_Name Sample_Well Sample_Plate Sample_Group Pool_ID Sentrix_ID #&gt; 1 HL-60 A06 SMET0001 NA NA 5684819030 #&gt; 2 IGR-37 B06 SMET0001 NA NA 5684819030 #&gt; 3 WM793B C07 SMET0001 NA NA 5723654013 #&gt; 4 IGR39 C08 SMET0001 NA NA 5723654013 #&gt; 5 SW-480 D09 SMET0001 NA NA 5723654015 #&gt; 6 C32 E09 SMET0001 NA NA 5723654015 #&gt; Sentrix_Position Investigator Project Tissue #&gt; 1 R05C01 Catia Moutinio &lt;NA&gt; HAEMATOPOIETIC AND LYMPHOID TISSUE #&gt; 2 R06C01 Javi Carmona &lt;NA&gt; SKIN #&gt; 3 R03C01 Javi Carmona &lt;NA&gt; SKIN #&gt; 4 R05C02 Javi Carmona &lt;NA&gt; SKIN #&gt; 5 R02C02 Javi Carmona &lt;NA&gt; LARGE INTESTINE #&gt; 6 R03C02 Catia Moutinio &lt;NA&gt; SKIN #&gt; Type EBV Cell_Line Wildtype Normal Coment Scan_Date #&gt; 1 ACUTE MYELOID LEUKEMIA No YES Yes No &lt;NA&gt; 2011-02-12 #&gt; 2 MELANOMA No YES Yes No Metastasis 2011-02-12 #&gt; 3 MELANOMA No YES Yes No Metastasis 2011-02-12 #&gt; 4 MELANOMA No YES Yes No Primary 2011-02-12 #&gt; 5 ADENOCARCINOMA No YES Yes No Primary 2011-02-12 #&gt; 6 MELANOMA No YES Yes No &lt;NA&gt; 2011-02-12 #&gt; GDSC1 GDSC2 cosmic_id #&gt; 1 blood acute_myeloid_leukaemia 905938 #&gt; 2 skin melanoma 1240153 #&gt; 3 skin melanoma 1299081 #&gt; 4 skin melanoma 1298148 #&gt; 5 &lt;NA&gt; &lt;NA&gt; NA #&gt; 6 skin melanoma 906830 GDSC_methylation_model_list$sampleid &lt;- paste0( &quot;X&quot;, GDSC_methylation_model_list$Sentrix_ID, &quot;_&quot;, GDSC_methylation_model_list$Sentrix_Position ) colnames(GDSC_methylation) %in% GDSC_methylation_model_list$sampleid |&gt; table() #&gt; #&gt; TRUE #&gt; 100 colnames(GDSC_methylation) &lt;- GDSC_methylation_model_list$Sample_Name[ match(colnames(GDSC_methylation), GDSC_methylation_model_list$sampleid) ] GDSC_methylation[1:5, 1:5] #&gt; A673 RT4 8-MG-BA U-118-MG CHAGO-K-1 #&gt; chr1:1051178-1052445 0.3733729 0.4144962 0.2892333 0.3023764 0.3880624 #&gt; chr1:109824313-109824526 0.4644322 0.5959816 0.5048080 0.4594520 0.5114854 #&gt; chr1:109825710-109826207 0.1411910 0.1770613 0.1668371 0.1698714 0.1706867 #&gt; chr1:110008962-110010124 0.4143231 0.5317602 0.5259936 0.4551888 0.4740822 #&gt; chr1:110527248-110528026 0.3022454 0.1882153 0.2679353 0.2989812 0.2603969 We have provided a few other subsetted datasets. A full list is available from Reference. We encourage independent exploration of these datasets. Creating Expression Matrices for Pharmacogenomic Analysis To facilitate downstream pharmacogenomic analysis, we want to create an expression matrix such that: Features are the rows Samples are the columns Feature expression as the individual values Below, we show a example of such matrix using dummy data. dummy_data &lt;- setNames( as.data.frame(replicate(5, rnorm(5))), paste0(&quot;Sample&quot;, 1:5) ) rownames(dummy_data) &lt;- paste0(&quot;Feature&quot;, 1:5) dummy_data #&gt; Sample1 Sample2 Sample3 Sample4 Sample5 #&gt; Feature1 0.1954394 -0.68858053 0.7077409 -0.2662768 1.8947974 #&gt; Feature2 -0.2004850 -0.67917315 -1.0818676 1.4058367 -0.3866877 #&gt; Feature3 -0.4919300 0.21579079 -1.7051469 -0.7585862 -0.6503987 #&gt; Feature4 0.4301351 0.09220137 -1.7222869 -0.4767112 0.1007024 #&gt; Feature5 -1.6509797 2.16440696 -1.2890662 2.0934868 0.9962919 Let’s revisit the RNA-Seq example. The data is currently in a long format (i.e. there is one row for each sample-feature observation). GDSC_rnaseq |&gt; head() #&gt; model_id model_name data_source gene_id gene_symbol read_count fpkm #&gt; 1 SIDM00794 A388 sanger SIDG00082 ABCC6 10 0.01 #&gt; 2 SIDM00794 A388 sanger SIDG00106 ABCF3 20264 25.95 #&gt; 3 SIDM00794 A388 sanger SIDG00108 ABCG2 1070 1.47 #&gt; 4 SIDM00794 A388 sanger SIDG00148 ABI3 6 0.02 #&gt; 5 SIDM00794 A388 sanger SIDG00177 ACADSB 1410 1.50 #&gt; 6 SIDM00794 A388 sanger SIDG00198 ACER1 12 0.06 GDSC_rnaseq |&gt; dim() #&gt; [1] 135000 7 # number of cell line samples length(unique(GDSC_rnaseq$model_id)) #&gt; [1] 100 # number of genes length(unique(GDSC_rnaseq$gene_id)) #&gt; [1] 1350 We want to convert this into a wide format such that each row is a gene, each column is a sample, and the values are the gene expression. expr &lt;- reshape2::dcast(GDSC_rnaseq, gene_id ~ model_name, value.var = &quot;fpkm&quot;) rownames(expr) &lt;- expr$gene_id expr$gene_id &lt;- NULL expr[1:5, 1:10] #&gt; A388 A427 BB65-RCC Becker BICR78 C-33-A Ca-Ski Ca9-22 CCK-81 CHL-1 #&gt; SIDG00082 0.01 0.29 0.04 0.15 0.03 0.01 0.01 0.01 0.94 1.23 #&gt; SIDG00106 25.95 16.45 8.19 13.88 14.04 10.99 16.42 9.04 9.37 14.86 #&gt; SIDG00108 1.47 0.52 0.02 0.03 1.02 0.01 0.27 0.09 0.01 0.04 #&gt; SIDG00148 0.02 0.02 0.35 0.01 0.00 0.02 0.00 0.10 0.00 0.00 #&gt; SIDG00177 1.50 6.18 3.07 3.40 1.97 7.21 1.01 1.83 5.56 11.63 expr |&gt; dim() #&gt; [1] 1350 100 Notice that we have the 1350 genes as the rows and the 100 cell lines as the columns. Feature Extraction Techniques to Define Biomarkers While using the continuous expression of single features is a convenient method for quantifying biomarkers, there are cases when other techniques are needed and/or are more appropriate. Binarization Recall that the driver mutations data was not presented as continuous numeric values. One method to prepare this data is to binarize the mutation status. GDSC_drivers |&gt; head() #&gt; gene_id gene_symbol model_id protein_mutation rna_mutation #&gt; 1 SIDG27130 RGPD3 SIDM02101 p.N241fs*6 r.809_819delAAUCUUAUGCU #&gt; 2 SIDG08129 ESR1 SIDM02095 p.L15fs*69 r.412_416delACUGC #&gt; 3 SIDG03559 CBLC SIDM02090 p.Q419fs*81 r.1295_1296insc #&gt; 4 SIDG02114 BAP1 SIDM02090 p.C91Y r.402g&gt;a #&gt; 5 SIDG02114 BAP1 SIDM02090 p.N78S r.363a&gt;g #&gt; 6 SIDG36265 SPEN SIDM02089 p.R753fs*53 r.2618_2627delAGGAGGCUUU #&gt; cdna_mutation cancer_driver cancer_predisposition_variant #&gt; 1 c.721_731delAATCTTATGCT True False #&gt; 2 c.42_46delACTGC True False #&gt; 3 c.1253_1254insC True False #&gt; 4 c.272G&gt;A True False #&gt; 5 c.233A&gt;G True False #&gt; 6 c.2257_2266delAGGAGGCTTT True False #&gt; effect vaf coding source model_name #&gt; 1 frameshift 0.2319 True Sanger Mesobank_CellLine-53T #&gt; 2 frameshift 0.4259 True Sanger Mesobank_CellLine-26 #&gt; 3 frameshift 0.5217 True Sanger Mesobank_CellLine-50T #&gt; 4 missense 0.5217 True Sanger Mesobank_CellLine-50T #&gt; 5 missense 0.4595 True Sanger Mesobank_CellLine-50T #&gt; 6 frameshift 0.6333 True Sanger Mesobank_CellLine-45 Looking at the first row, we can see that there is a mutation on the RGPD3 gene in the SIDM02101 cell line model. We would represent such mutation events with 1. The code below again casts the long data frame into a wide format. This time we specify an aggregate function length(), which returns the number of rows (mutation events) for each gene-cell line pair. This was done by passing the option fun.aggregate = length. expr &lt;- reshape2::dcast( GDSC_drivers, gene_symbol ~ model_id, value.var = &quot;cdna_mutation&quot;, fun.aggregate = length ) rownames(expr) &lt;- expr$gene_symbol expr$gene_symbol &lt;- NULL expr[&quot;RGPD3&quot;, &quot;SIDM02101&quot;] #&gt; [1] 1 expr[1:5, 1:10] #&gt; SIDM00001 SIDM00002 SIDM00003 SIDM00006 SIDM00007 SIDM00008 SIDM00009 #&gt; ABCB1 0 0 0 0 0 0 0 #&gt; ABI1 0 0 0 0 0 0 0 #&gt; ABL1 0 0 0 0 0 0 0 #&gt; ABL2 0 0 0 0 0 0 0 #&gt; ACVR1 0 0 0 0 0 0 0 #&gt; SIDM00011 SIDM00013 SIDM00014 #&gt; ABCB1 0 0 0 #&gt; ABI1 0 0 0 #&gt; ABL1 0 0 0 #&gt; ABL2 0 1 0 #&gt; ACVR1 0 0 0 There was one mutation event on the RGPD3 gene in the SIDM02101 cell line model, hence the value of this combination is 1. Mutation events are relatively sparse, so we see 0 for the majority of the matrix. Signature extraction There are cases when individual features have low predictive power, but when combined become much more informative of drug response. Let’s revisit our methylation data. Recall that each row is a CpG site. There are 1000 CpG sites. GDSC_methylation[1:5, 1:5] #&gt; A673 RT4 8-MG-BA U-118-MG CHAGO-K-1 #&gt; chr1:1051178-1052445 0.3733729 0.4144962 0.2892333 0.3023764 0.3880624 #&gt; chr1:109824313-109824526 0.4644322 0.5959816 0.5048080 0.4594520 0.5114854 #&gt; chr1:109825710-109826207 0.1411910 0.1770613 0.1668371 0.1698714 0.1706867 #&gt; chr1:110008962-110010124 0.4143231 0.5317602 0.5259936 0.4551888 0.4740822 #&gt; chr1:110527248-110528026 0.3022454 0.1882153 0.2679353 0.2989812 0.2603969 GDSC_methylation |&gt; dim() #&gt; [1] 1000 100 Signatures refer to combinations of features that form some pattern with biological relevance. For example, you may choose to define a signature X to represent CpG sites located on promoters of genes involved in pathway Y. For simplicity, we can define some arbituary signatures from our CpG sites. set.seed(123) signatures &lt;- data.frame( CpG = rownames(GDSC_methylation), Signature = sample(gl(10, 100, length = 1000)) ) signatures |&gt; head() #&gt; CpG Signature #&gt; 1 chr1:1051178-1052445 5 #&gt; 2 chr1:109824313-109824526 5 #&gt; 3 chr1:109825710-109826207 2 #&gt; 4 chr1:110008962-110010124 6 #&gt; 5 chr1:110527248-110528026 2 #&gt; 6 chr1:114354373-114355300 10 Each of the 1000 CpG sites was randomly assigned to one of 10 signatures. Next we want to quantify the signature for each cell line. Again, for simplicity, we will sum the beta values across each CpG for each signature. sScores &lt;- data.frame(matrix(NA, nrow = 0, ncol = 100)) for (s in c(1:10)) { # get CpGs within each signature cpgs &lt;- signatures[signatures$Signature == s, ]$CpG mSig &lt;- GDSC_methylation[rownames(GDSC_methylation) %in% cpgs, ] # compute sum of beta values for each cell line sSum &lt;- colSums(mSig) sScores &lt;- rbind(sScores, sSum) } rownames(sScores) &lt;- paste0(&quot;Signature&quot;, 1:10) colnames(sScores) &lt;- colnames(GDSC_methylation) sScores[1:10, 1:5] #&gt; A673 RT4 8-MG-BA U-118-MG CHAGO-K-1 #&gt; Signature1 35.73567 41.50092 30.31945 35.03195 40.93194 #&gt; Signature2 36.54479 41.78597 34.23020 37.28902 42.43054 #&gt; Signature3 35.08198 39.01984 32.67874 35.14082 39.57340 #&gt; Signature4 37.26978 42.31938 35.94349 38.44868 41.68582 #&gt; Signature5 37.06404 42.90746 32.04316 37.13874 38.69905 #&gt; Signature6 35.32663 40.04647 31.79493 34.86532 39.63569 #&gt; Signature7 36.46212 40.74357 33.85272 36.77940 40.16127 #&gt; Signature8 35.69553 40.46161 32.70537 36.50410 39.12737 #&gt; Signature9 34.37157 38.31962 31.18276 34.40533 39.80003 #&gt; Signature10 40.49063 42.52888 33.00193 39.79155 39.62519 We now have a new expression matrix, this time of the 10 defined signatures for each of our cell lines. Individual Practice For the remainder of this session, we provide more sample datasets to practice the above techniques. CCLE_chromatin.rda CCLE_metabolomics.rda CCLE_model_list.rda CCLE_rrpa.rda Lab Completed! Congratulations! You have completed Lab 1! "],["module-2-data-preparation-for-pharmacogenomic-analysis.html", "Module 2: Data Preparation for Pharmacogenomic Analysis Lecture Lab", " Module 2: Data Preparation for Pharmacogenomic Analysis Lecture Lab Overview Instructor(s) Name and Contact Information Jermiah J. Joseph jermiah.joseph@uhn.ca Almas Khan almas.khan@uhn.ca Julia Nguyen julia.nguyen@uhn.ca Learning Goals Understand the data structure of a PharmacoSet Learn how to access features and metadata from a PharmacoSet Learn how to plot batch effects using PCA and run correction method (SVA) Learn how to filter out outliers and missing values Learning Objectives Describe the use cases for PharmacoGx in Pharmacogenomics Understand the structure of the CoreSet and PharmacoSet classes to facilitate their use in subsequent analyses Download/load a PharmacoSet using PharmacoGx or orcestra.ca Subset and filter a PharmacoSet by samples and/or treatments Access the molecular features, dose-response and metadata contained within the PharmacoSet Perform quality control on a PharmacoSet by identifying and removing outliers and missing values Perform batch correction on a PharmacoSet using the sva package Setup Use Cases for PharmacoGx Downloading Data from orcestra.ca available &lt;- PharmacoGx::availablePSets() |&gt; data.table::as.data.table() print(names(available)) #&gt; [1] &quot;Dataset Name&quot; &quot;Date Created&quot; &quot;PSet Name&quot; &quot;version&quot; &quot;type&quot; #&gt; [6] &quot;publication&quot; &quot;DOI&quot; &quot;Download&quot; print(available[, c(&quot;Dataset Name&quot;, &quot;PSet Name&quot;, &quot;version&quot;)]) #&gt; Dataset Name PSet Name version #&gt; &lt;char&gt; &lt;char&gt; &lt;char&gt; #&gt; 1: GDSC GDSC_2020(v2-8.2) 2020(v2-8.2) #&gt; 2: FIMM FIMM_2016 2016 #&gt; 3: Tavor Tavor_2020 2020 #&gt; 4: NCI60 NCI60_2021 2021 #&gt; 5: UHNBreast UHNBreast_2019 2019 #&gt; 6: GDSC GDSC_2020(v1-8.2) 2020(v1-8.2) #&gt; 7: PRISM PRISM_2020 2020 #&gt; 8: BeatAML BeatAML_2018 2018 #&gt; 9: gCSI gCSI_2019 2019 #&gt; 10: CTRPv2 CTRPv2_2015 2015 #&gt; 11: GRAY GRAY_2017 2017 #&gt; 12: CCLE CCLE_2015 2015 #&gt; 13: PDTX PDTX_2019 2019 #&gt; 14: GBM GBM_scr2 2021 #&gt; 15: GBM GBM_scr3 2021 #&gt; 16: NCISarcoma NCISarcoma_2015 2015 #&gt; 17: TCL38 TCL38 2015 The following function from PharmacoGx can be used to download any of the available PSets from orcestra.ca. The command to do so is: PharmacoGx::downloadPSet( name = &quot;CCLE_2015&quot;, saveDir = &quot;../psets&quot;, # change this directory as you see fit timeout = 3600, verbose = TRUE ) # Note: this may take a while to download as the files are stored in # Zenodo and are quite large For convenience and in the interest of time, we have created a PharmacoSet to be used in this tutorial. We will be interacting with this dataset for the remainder of the tutorial. pset &lt;- CBWWorkshop2024::dummy_pset pset #&gt; &lt;PharmacoSet&gt; #&gt; Name: dummy_pset #&gt; Date Created: Tue Oct 15 23:31:41 2024 #&gt; Number of samples: 50 #&gt; Molecular profiles: &lt;MultiAssayExperiment&gt; #&gt; ExperimentList class object of length 2: #&gt; [1] rnaseq.tpm : SummarizedExperiment with 100 rows and 50 columns #&gt; [2] rnaseq.tpm.batch : SummarizedExperiment with 100 rows and 50 columns #&gt; Treatment response: &lt;TreatmentResponseExperiment&gt; #&gt; dim: 4847 52 #&gt; assays(1): sensitivity #&gt; rownames(4847): 1e-07:Ixabepilone:1 1e-06:Ixabepilone:1 ... 1000:Nelarabine:1 4000:Ifosfamide:1 #&gt; rowData(4): treatmentdose treatmentid tech_rep CONC1 #&gt; colnames(52): 786-O:1 A-498:1 A-549:1 ... UACC-257:1 UACC-62:1 UO-31:1 #&gt; colData(3): sampleid bio_rep PANEL #&gt; metadata(0): none Understanding the PharmacoSet Data Structure The PharmacoSet class is a container for pharmacogenomic data. This pharmacogenomic data is typically generated from high-throughput screening experiments where cell lines are treated with a panel of drugs at multiple doses and the response is measured using a molecular assay. Pharmacogenomic data is located in a PharmacoSet within its slots, which are accessed using the @ operator. slotNames(pset) #&gt; [1] &quot;treatmentResponse&quot; &quot;annotation&quot; &quot;molecularProfiles&quot; #&gt; [4] &quot;sample&quot; &quot;treatment&quot; &quot;datasetType&quot; #&gt; [7] &quot;perturbation&quot; &quot;curation&quot; ### Metadata Metadata for cell-lines (samples) and drugs (treatments) are stored in the sample and treatment slots, respectively. These are data frames with rows corresponding to samples or treatments and columns corresponding to metadata fields. The metadata fields are typically a combination of data from the original data source, and curated data from external sources such as Cellosaurus,DrugBank, and PubChem. View the sample slot We can access the sampleNames of the PharmacoSet: PharmacoGx::sampleNames(pset) #&gt; [1] &quot;NCI-H23&quot; &quot;HOP-62&quot; &quot;SNB-75&quot; &quot;HL-60(TB)&quot; &quot;A-549&quot; #&gt; [6] &quot;SF268&quot; &quot;SNB-19&quot; &quot;SF295&quot; &quot;OVCAR-5&quot; &quot;U-251MG&quot; #&gt; [11] &quot;MCF-7&quot; &quot;MDA-MB-231&quot; &quot;MDA-MB-435&quot; &quot;BT-549&quot; &quot;SK-MEL-5&quot; #&gt; [16] &quot;MOLT-4&quot; &quot;DU145&quot; &quot;NCI-ADR-RES&quot; &quot;OVCAR-3&quot; &quot;COLO 205&quot; #&gt; [21] &quot;SK-OV-3&quot; &quot;CCRF-CEM&quot; &quot;SR&quot; &quot;IGROV-1&quot; &quot;SW620&quot; #&gt; [26] &quot;Hs 578T&quot; &quot;HCT 116&quot; &quot;UACC-62&quot; &quot;EKVX&quot; &quot;HCT 15&quot; #&gt; [31] &quot;OVCAR-8&quot; &quot;UACC-257&quot; &quot;SF539&quot; &quot;UO-31&quot; &quot;M14&quot; #&gt; [36] &quot;KM12&quot; &quot;T-47D&quot; &quot;Malme-3M&quot; &quot;Caki-1&quot; &quot;A-498&quot; #&gt; [41] &quot;SK-MEL-28&quot; &quot;RPMI-8226&quot; &quot;NCI-H460&quot; &quot;NCI-H322M&quot; &quot;NCI-H226&quot; #&gt; [46] &quot;K-562&quot; &quot;786-O&quot; &quot;SK-MEL-2&quot; &quot;HCC2998&quot; &quot;NCI-H522&quot; To get all the metadata associated with the samples, we can access the sample slot: pset@sample |&gt; str() #&gt; &#39;data.frame&#39;: 50 obs. of 7 variables: #&gt; $ sampleid : chr &quot;NCI-H23&quot; &quot;HOP-62&quot; &quot;SNB-75&quot; &quot;HL-60(TB)&quot; ... #&gt; $ tissueid : chr &quot;Lung&quot; &quot;Lung&quot; &quot;CNS/Brain&quot; &quot;Myeloid&quot; ... #&gt; $ cellosaurus_disease : chr &quot;Lung adenocarcinoma&quot; &quot;Lung adenocarcinoma&quot; &quot;Glioblastoma&quot; &quot;Acute myeloid leukemia&quot; ... #&gt; $ cellosaurus_id : chr &quot;CVCL_1547&quot; &quot;CVCL_1285&quot; &quot;CVCL_1706&quot; &quot;CVCL_A794&quot; ... #&gt; $ NCI_ALMANAC.sampleid: chr &quot;NCI-H23&quot; &quot;HOP-62&quot; &quot;SNB-75&quot; &quot;HL-60(TB)&quot; ... #&gt; $ NCI_ALMANAC.disease : chr &quot;Non-Small Cell Lung Cancer&quot; &quot;Non-Small Cell Lung Cancer&quot; &quot;CNS Cancer&quot; &quot;Leukemia&quot; ... #&gt; $ pharmacodb_cid : chr &quot;NCIH23_1085_2019&quot; &quot;HOP62_561_2019&quot; &quot;SNB75_1430_2019&quot; &quot;HL-60(TB)6502021_&quot; ... We can see from the sample slot that there are 50 samples in this PharmacoSet. View the treatment slot Similar to the sample, we can access the treatmentNames of the PharmacoSet: PharmacoGx::treatmentNames(pset) |&gt; head() #&gt; [1] &quot;Ixabepilone&quot; &quot;Clofarabine&quot; &quot;Dasatinib&quot; &quot;Vincristine&quot; &quot;Imiquimod&quot; #&gt; [6] &quot;Paclitaxel&quot; To get all the metadata associated with the treatments, we can access the treatment slot: pset@treatment |&gt; str() #&gt; &#39;data.frame&#39;: 22 obs. of 3 variables: #&gt; $ treatmentid: chr &quot;Ixabepilone&quot; &quot;Clofarabine&quot; &quot;Dasatinib&quot; &quot;Vincristine&quot; ... #&gt; $ cid : int 6445540 119182 3062316 5978 57469 36314 13342 54611422 2141 176871 ... #&gt; $ inchikey : chr &quot;FABUFPQFXZVHFB-PVYNADRNSA-N&quot; &quot;WDDPHFBMKLOVOX-UHFFFAOYSA-N&quot; &quot;ZBNZXTGUTAYRHI-UHFFFAOYSA-N&quot; &quot;&quot; ... There are also 22 treatments used. Molecular Profiles In PharmacoGx, molecular profiles refer to any data that is measured on the samples in the PharmacoSet. This can include gene expression, copy number, mutation, or any other type of data that can be measured on a sample. Each Molecular Data Type (mDataType) is stored in a SummarizedExperiment. All the SummarizedExperiment objects are stored in a container called a MultiAssayExperiment which can be accessed through the molecularProfiles slot. MultiAssayExperiment and SummarizedExperiment #### View the molecularProfiles Slot pset@molecularProfiles #&gt; A MultiAssayExperiment object of 2 listed #&gt; experiments with user-defined names and respective classes. #&gt; Containing an ExperimentList class object of length 2: #&gt; [1] rnaseq.tpm: SummarizedExperiment with 100 rows and 50 columns #&gt; [2] rnaseq.tpm.batch: SummarizedExperiment with 100 rows and 50 columns #&gt; Functionality: #&gt; experiments() - obtain the ExperimentList instance #&gt; colData() - the primary/phenotype DataFrame #&gt; sampleMap() - the sample coordination DataFrame #&gt; `$`, `[`, `[[` - extract colData columns, subset, or experiment #&gt; *Format() - convert into a long or wide DataFrame #&gt; assays() - convert ExperimentList to a SimpleList of matrices #&gt; exportClass() - save data to flat files Treatment Response The treatment response data was traditionally stored in a list. To accelerate analysis, we have developed a new class called the TreatmentResponseExperiment (TRE) which has been specifically designed to handle high dimensional biological stimulus-response data. View the treatmentResponse slot pset@treatmentResponse #&gt; &lt;TreatmentResponseExperiment&gt; #&gt; dim: 4847 52 #&gt; assays(1): sensitivity #&gt; rownames(4847): 1e-07:Ixabepilone:1 1e-06:Ixabepilone:1 ... 1000:Nelarabine:1 4000:Ifosfamide:1 #&gt; rowData(4): treatmentdose treatmentid tech_rep CONC1 #&gt; colnames(52): 786-O:1 A-498:1 A-549:1 ... UACC-257:1 UACC-62:1 UO-31:1 #&gt; colData(3): sampleid bio_rep PANEL #&gt; metadata(0): none To view all the methods available for the TreatmentResponseExperiment class, we can use the methods function: methods(class = &quot;TreatmentResponseExperiment&quot;) #&gt; [1] [ [[ [[&lt;- #&gt; [4] $ $&lt;- aggregate #&gt; [7] assay assay&lt;- assayCols #&gt; [10] assayIndex assayKeys assayNames #&gt; [13] assays assays&lt;- buildComboProfiles #&gt; [16] coerce colData colData&lt;- #&gt; [19] colIDs colMeta colnames #&gt; [22] computeZIPdelta dim dimnames #&gt; [25] endoaggregate getIntern idCols #&gt; [28] mergeAssays metadata metadata&lt;- #&gt; [31] names reindex rowData #&gt; [34] rowData&lt;- rowIDs rowMeta #&gt; [37] rownames show subset #&gt; [40] treatmentResponse&lt;- updateObject #&gt; see &#39;?methods&#39; for accessing help and source code Subsetting a PharmacoSet Subset by sampleNames and/or treatmentNames When subsetting a PharmacoSet object by sample names, both the MultiAssayExperiment and TreatmentResponseExperiment objects will be subsetted so all their internal Experiments only contain data for the samples of interest. However, when subsetting by treatment names, only the TRE object will be subsetted. PharmacoGx::subsetBySample( pset, sample = PharmacoGx::sampleNames(pset)[1:5] ) #&gt; &lt;PharmacoSet&gt; #&gt; Name: dummy_pset #&gt; Date Created: Tue Oct 15 23:31:41 2024 #&gt; Number of samples: 5 #&gt; Molecular profiles: &lt;MultiAssayExperiment&gt; #&gt; ExperimentList class object of length 2: #&gt; [1] rnaseq.tpm : SummarizedExperiment with 100 rows and 5 columns #&gt; [2] rnaseq.tpm.batch : SummarizedExperiment with 100 rows and 5 columns #&gt; Treatment response: &lt;TreatmentResponseExperiment&gt; #&gt; dim: 4440 4 #&gt; assays(1): sensitivity #&gt; rownames(4440): 1e-07:Ixabepilone:1 1e-06:Ixabepilone:1 ... 1000:Nelarabine:1 4000:Ifosfamide:1 #&gt; rowData(4): treatmentdose treatmentid tech_rep CONC1 #&gt; colnames(4): A-549:1 HOP-62:1 NCI-H23:1 SNB-75:1 #&gt; colData(3): sampleid bio_rep PANEL #&gt; metadata(0): none PharmacoGx::subsetByTreatment( pset, treatment = PharmacoGx::treatmentNames(pset)[1:5] ) #&gt; &lt;PharmacoSet&gt; #&gt; Name: dummy_pset #&gt; Date Created: Tue Oct 15 23:31:41 2024 #&gt; Number of samples: 50 #&gt; Molecular profiles: &lt;MultiAssayExperiment&gt; #&gt; ExperimentList class object of length 2: #&gt; [1] rnaseq.tpm : SummarizedExperiment with 100 rows and 50 columns #&gt; [2] rnaseq.tpm.batch : SummarizedExperiment with 100 rows and 50 columns #&gt; Treatment response: &lt;TreatmentResponseExperiment&gt; #&gt; dim: 883 51 #&gt; assays(1): sensitivity #&gt; rownames(883): 1e-07:Ixabepilone:1 1e-06:Ixabepilone:1 ... 7:Clofarabine:1 10:Clofarabine:1 #&gt; rowData(4): treatmentdose treatmentid tech_rep CONC1 #&gt; colnames(51): 786-O:1 A-498:1 A-549:1 ... UACC-257:1 UACC-62:1 UO-31:1 #&gt; colData(3): sampleid bio_rep PANEL #&gt; metadata(0): none Subsetting Using sample and treatment Metadata The utility of the metadata slots in the PharmacoSet class. unique(pset@sample$tissueid) #&gt; [1] &quot;Lung&quot; &quot;CNS/Brain&quot; &quot;Myeloid&quot; #&gt; [4] &quot;Ovary/Fallopian Tube&quot; &quot;Breast&quot; &quot;Skin&quot; #&gt; [7] &quot;Lymphoid&quot; &quot;Prostate&quot; &quot;Bowel&quot; #&gt; [10] &quot;Kidney&quot; &quot;Pleura&quot; tissues_of_interest &lt;- c(&quot;Kidney&quot;) (samples_of_interest &lt;- pset@sample[ pset@sample$tissueid %in% tissues_of_interest, &quot;sampleid&quot; ] ) #&gt; [1] &quot;UO-31&quot; &quot;Caki-1&quot; &quot;A-498&quot; &quot;786-O&quot; PharmacoGx::subsetBySample( pset, samples_of_interest ) #&gt; &lt;PharmacoSet&gt; #&gt; Name: dummy_pset #&gt; Date Created: Tue Oct 15 23:31:41 2024 #&gt; Number of samples: 4 #&gt; Molecular profiles: &lt;MultiAssayExperiment&gt; #&gt; ExperimentList class object of length 2: #&gt; [1] rnaseq.tpm : SummarizedExperiment with 100 rows and 4 columns #&gt; [2] rnaseq.tpm.batch : SummarizedExperiment with 100 rows and 4 columns #&gt; Treatment response: &lt;TreatmentResponseExperiment&gt; #&gt; dim: 4285 4 #&gt; assays(1): sensitivity #&gt; rownames(4285): 1e-07:Ixabepilone:1 1e-06:Ixabepilone:1 ... 1000:Nelarabine:1 4000:Ifosfamide:1 #&gt; rowData(4): treatmentdose treatmentid tech_rep CONC1 #&gt; colnames(4): 786-O:1 A-498:1 Caki-1:1 UO-31:1 #&gt; colData(3): sampleid bio_rep PANEL #&gt; metadata(0): none A concise way to subset by sample in one step: PharmacoGx::subsetBySample( pset, sample = pset@sample[ pset@sample$tissueid == &quot;Kidney&quot;, &quot;sampleid&quot; ] ) #&gt; &lt;PharmacoSet&gt; #&gt; Name: dummy_pset #&gt; Date Created: Tue Oct 15 23:31:41 2024 #&gt; Number of samples: 4 #&gt; Molecular profiles: &lt;MultiAssayExperiment&gt; #&gt; ExperimentList class object of length 2: #&gt; [1] rnaseq.tpm : SummarizedExperiment with 100 rows and 4 columns #&gt; [2] rnaseq.tpm.batch : SummarizedExperiment with 100 rows and 4 columns #&gt; Treatment response: &lt;TreatmentResponseExperiment&gt; #&gt; dim: 4285 4 #&gt; assays(1): sensitivity #&gt; rownames(4285): 1e-07:Ixabepilone:1 1e-06:Ixabepilone:1 ... 1000:Nelarabine:1 4000:Ifosfamide:1 #&gt; rowData(4): treatmentdose treatmentid tech_rep CONC1 #&gt; colnames(4): 786-O:1 A-498:1 Caki-1:1 UO-31:1 #&gt; colData(3): sampleid bio_rep PANEL #&gt; metadata(0): none Computing Over a TreatmentResponseExperiment The TreatmentResponseExperiment class has been designed to facilitate more than just storing data efficiently. Once the data is curated and stored safely inside our object, we are ready to start answering questions. First, let’s extract the TRE to work with: tre &lt;- pset@treatmentResponse show(tre) #&gt; &lt;TreatmentResponseExperiment&gt; #&gt; dim: 4847 52 #&gt; assays(1): sensitivity #&gt; rownames(4847): 1e-07:Ixabepilone:1 1e-06:Ixabepilone:1 ... 1000:Nelarabine:1 4000:Ifosfamide:1 #&gt; rowData(4): treatmentdose treatmentid tech_rep CONC1 #&gt; colnames(52): 786-O:1 A-498:1 A-549:1 ... UACC-257:1 UACC-62:1 UO-31:1 #&gt; colData(3): sampleid bio_rep PANEL #&gt; metadata(0): none Aggregating Over the TreatmentResponseExperiment The aggregate function is a powerful tool that allows us to summarize the data in a TreatmentResponseExperiment object. tre |&gt; aggregate( assay = &quot;sensitivity&quot;, N = .N, by = c(&quot;treatmentid&quot;, &quot;treatmentdose&quot;, &quot;sampleid&quot;, &quot;bio_rep&quot;) ) #&gt; treatmentid treatmentdose sampleid bio_rep N #&gt; &lt;char&gt; &lt;num&gt; &lt;char&gt; &lt;int&gt; &lt;int&gt; #&gt; 1: Ixabepilone 1e-07 786-O 1 1 #&gt; 2: Ixabepilone 1e-07 A-498 1 1 #&gt; 3: Ixabepilone 1e-07 A-549 1 1 #&gt; 4: Ixabepilone 1e-07 BT-549 1 1 #&gt; 5: Ixabepilone 1e-07 COLO 205 1 1 #&gt; --- #&gt; 9036: Ifosfamide 4e+03 T-47D 1 1 #&gt; 9037: Ifosfamide 4e+03 U-251MG 1 1 #&gt; 9038: Ifosfamide 4e+03 UACC-257 1 1 #&gt; 9039: Ifosfamide 4e+03 UACC-62 1 1 #&gt; 9040: Ifosfamide 4e+03 UO-31 1 1 You can also use the subset function to subset the TreatmentResponseExperiment object before performing aggregate. Additionally, you can even subset over the result of an aggregate operation. tre |&gt; subset(treatmentid %in% c(&quot;Doxorubicin&quot;, &quot;Ixabepilone&quot;)) |&gt; aggregate( assay = &quot;sensitivity&quot;, N = .N, by = c(&quot;treatmentid&quot;, &quot;treatmentdose&quot;, &quot;sampleid&quot;, &quot;bio_rep&quot;) ) |&gt; subset(N &gt; 1 &amp; sampleid == &quot;A-498&quot;) #&gt; treatmentid treatmentdose sampleid bio_rep N #&gt; &lt;char&gt; &lt;num&gt; &lt;char&gt; &lt;int&gt; &lt;int&gt; #&gt; 1: Ixabepilone 3e-05 A-498 1 2 #&gt; 2: Doxorubicin 5e-05 A-498 1 102 #&gt; 3: Ixabepilone 3e-04 A-498 1 2 #&gt; 4: Doxorubicin 5e-04 A-498 1 102 #&gt; 5: Ixabepilone 3e-03 A-498 1 10 #&gt; 6: Doxorubicin 5e-03 A-498 1 122 #&gt; 7: Ixabepilone 3e-02 A-498 1 8 #&gt; 8: Doxorubicin 5e-02 A-498 1 122 #&gt; 9: Ixabepilone 3e-01 A-498 1 8 #&gt; 10: Doxorubicin 5e-01 A-498 1 122 #&gt; 11: Doxorubicin 5e+00 A-498 1 102 Plotting the Number of Replicates The last two examples have shown that there are technical replicates in the data. We can visualize the number of replicates using a histogram. tre |&gt; aggregate( assay = &quot;sensitivity&quot;, N = .N, by = c(&quot;treatmentid&quot;, &quot;treatmentdose&quot;, &quot;sampleid&quot;, &quot;bio_rep&quot;) ) |&gt; with( expr = hist( N, main = &quot;Histogram of Number of Replicates&quot;, xlab = &quot;Number of Replicates&quot; ) ) Summarize Over Technical Replicates Depending on the experiment design, you will need to choose how you want to proceed with the data. One common approach is to summarize the technical replicates into a single value, this can be done by taking the mean, median, or any other summary statistic. Endoaggregate In the interest of computation time and resources, we want to summarize the technical replicates into a single value and store that result inside the TreatmentResponseExperiment. For this, we have developed the endoaggregate method. This method will perform similar to the aggregate method, but will return a TreatmentResponseExperiment object with the summarized data as another assay. new_tre &lt;- tre |&gt; endoaggregate( N = .N, assay = &quot;sensitivity&quot;, target = &quot;tech_rep_counts&quot;, by = c(&quot;treatmentid&quot;, &quot;treatmentdose&quot;, &quot;sampleid&quot;, &quot;bio_rep&quot;) ) show(new_tre) #&gt; &lt;TreatmentResponseExperiment&gt; #&gt; dim: 4847 52 #&gt; assays(2): sensitivity tech_rep_counts #&gt; rownames(4847): 1e-07:Ixabepilone:1 1e-06:Ixabepilone:1 ... 1000:Nelarabine:1 4000:Ifosfamide:1 #&gt; rowData(4): treatmentdose treatmentid tech_rep CONC1 #&gt; colnames(52): 786-O:1 A-498:1 A-549:1 ... UACC-257:1 UACC-62:1 UO-31:1 #&gt; colData(3): sampleid bio_rep PANEL #&gt; metadata(0): none head(new_tre$tech_rep_counts[order(-N)]) #&gt; treatmentdose treatmentid sampleid bio_rep N #&gt; &lt;num&gt; &lt;char&gt; &lt;char&gt; &lt;int&gt; &lt;int&gt; #&gt; 1: 0.005 Doxorubicin HCT 116 1 153 #&gt; 2: 0.050 Doxorubicin HCT 116 1 153 #&gt; 3: 0.500 Doxorubicin HCT 116 1 153 #&gt; 4: 0.005 Doxorubicin NCI-ADR-RES 1 132 #&gt; 5: 0.050 Doxorubicin NCI-ADR-RES 1 132 #&gt; 6: 0.500 Doxorubicin NCI-ADR-RES 1 132 Let’s use this method to summarize the technical replicates by taking the mean of the viability values for each unique combination of treatmentid, treatmentdose, sampleid, and bio_rep. tre_avged &lt;- tre |&gt; endoaggregate( viability = mean(viability), assay = &quot;sensitivity&quot;, target = &quot;mean_sensitivity&quot;, by = c(&quot;treatmentid&quot;, &quot;treatmentdose&quot;, &quot;sampleid&quot;, &quot;bio_rep&quot;) ) str(tre_avged$mean_sensitivity) #&gt; Classes &#39;data.table&#39; and &#39;data.frame&#39;: 9040 obs. of 5 variables: #&gt; $ treatmentdose: num 1e-07 1e-07 1e-07 1e-07 1e-07 1e-07 1e-07 1e-07 1e-07 1e-07 ... #&gt; $ treatmentid : chr &quot;Ixabepilone&quot; &quot;Ixabepilone&quot; &quot;Ixabepilone&quot; &quot;Ixabepilone&quot; ... #&gt; $ sampleid : chr &quot;786-O&quot; &quot;A-498&quot; &quot;A-549&quot; &quot;BT-549&quot; ... #&gt; $ bio_rep : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ viability : num 98 99.7 99.3 96 103.7 ... #&gt; - attr(*, &quot;sorted&quot;)= chr [1:4] &quot;treatmentdose&quot; &quot;treatmentid&quot; &quot;sampleid&quot; &quot;bio_rep&quot; #&gt; - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; Computing Profiles tre_profiled &lt;- tre_avged |&gt; endoaggregate( { fit &lt;- PharmacoGx::logLogisticRegression(treatmentdose, viability) IC50 &lt;- PharmacoGx::computeIC50(treatmentdose, Hill_fit = fit) AAC &lt;- PharmacoGx::computeAUC(treatmentdose, Hill_fit = fit, area.type = &quot;Fitted&quot;) list( HS = fit[[&quot;HS&quot;]], E_inf = fit[[&quot;E_inf&quot;]] / 100, EC50 = fit[[&quot;EC50&quot;]], Rsq = as.numeric(unlist(attributes(fit))), AAC = AAC, IC50 = IC50 ) }, assay = &quot;mean_sensitivity&quot;, subset = treatmentid %in% rowData(tre_avged)[, unique(treatmentid)][1:3], by = c(&quot;treatmentid&quot;, &quot;sampleid&quot;, &quot;bio_rep&quot;), enlist = FALSE, target = &quot;profiles&quot; ) If we didn’t subset the TRE this computation will have taken a while since it is a computationally intensive operation and run on a single thread. Under the hood, the CoreGx package performs the aggregation. To speed up computation, it provides an nthread parameter to parallelize the computation. To determine a safe, and optimal number of threads to use, we can use the CoreGx::optimizeCoreGx function which will tell us a safe number of threads. Note The following two code chunks will not be evaluated in this vignette as it may take some time. CoreGx::optimizeCoreGx(tre_avged) Depending on your device, this number may vary. Let’s use a conservative number of threads for this example. THREADS &lt;- 6 # github runners provide 2c tre_profiled &lt;- tre_avged |&gt; endoaggregate( { fit &lt;- PharmacoGx::logLogisticRegression(treatmentdose, viability) IC50 &lt;- PharmacoGx::computeIC50(treatmentdose, Hill_fit = fit) AAC &lt;- PharmacoGx::computeAUC(treatmentdose, Hill_fit = fit, area.type = &quot;Fitted&quot;) list( HS = fit[[&quot;HS&quot;]], E_inf = fit[[&quot;E_inf&quot;]] / 100, EC50 = fit[[&quot;EC50&quot;]], Rsq = as.numeric(unlist(attributes(fit))), AAC = AAC, IC50 = IC50, mindose = min(treatmentdose), maxdose = max(treatmentdose), numdose = length(unique(treatmentdose)), minviability = min(viability), maxviability = max(viability) ) }, assay = &quot;mean_sensitivity&quot;, by = c(&quot;treatmentid&quot;, &quot;sampleid&quot;, &quot;bio_rep&quot;), enlist = FALSE, target = &quot;profiles&quot;, nthread = THREADS ) Let’s look at the profiles we have computed: show(tre_profiled) #&gt; &lt;TreatmentResponseExperiment&gt; #&gt; dim: 4847 52 #&gt; assays(3): sensitivity mean_sensitivity profiles #&gt; rownames(4847): 1e-07:Ixabepilone:1 1e-06:Ixabepilone:1 ... 1000:Nelarabine:1 4000:Ifosfamide:1 #&gt; rowData(4): treatmentdose treatmentid tech_rep CONC1 #&gt; colnames(52): 786-O:1 A-498:1 A-549:1 ... UACC-257:1 UACC-62:1 UO-31:1 #&gt; colData(3): sampleid bio_rep PANEL #&gt; metadata(0): none tre_profiled$profiles #&gt; Key: &lt;treatmentid, sampleid, bio_rep&gt; #&gt; treatmentid sampleid bio_rep HS E_inf EC50 Rsq AAC #&gt; &lt;char&gt; &lt;char&gt; &lt;int&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; #&gt; 1: Ixabepilone 786-O 1 1 0.22057530 0.03 0.9794689 12.531587 #&gt; 2: Ixabepilone A-498 1 1 0.31290066 0.03 0.9789242 11.047180 #&gt; 3: Ixabepilone A-549 1 1 0.14355321 0.03 0.9457645 13.769947 #&gt; 4: Ixabepilone BT-549 1 1 0.20976649 0.03 0.9608561 12.705370 #&gt; 5: Ixabepilone CCRF-CEM 1 1 0.02700157 0.03 0.8583904 25.321277 #&gt; --- #&gt; 147: Vinblastine T-47D 1 1 0.54684798 0.05 0.3701465 5.404228 #&gt; 148: Vinblastine U-251MG 1 1 0.23576667 0.01 0.5443226 19.888382 #&gt; 149: Vinblastine UACC-257 1 1 0.50895401 0.05 0.3843545 5.856146 #&gt; 150: Vinblastine UACC-62 1 1 0.31347623 0.01 0.5809319 17.866071 #&gt; 151: Vinblastine UO-31 1 1 0.68541114 0.10 0.6336420 2.367176 #&gt; IC50 #&gt; &lt;num&gt; #&gt; 1: 0.05368172 #&gt; 2: 0.08017131 #&gt; 3: 0.04208202 #&gt; 4: 0.05168252 #&gt; 5: 0.03171258 #&gt; --- #&gt; 147: NA #&gt; 148: 0.01892267 #&gt; 149: NA #&gt; 150: 0.02680624 #&gt; 151: NA Quality Control of Pharmacogenomic Datasets For the remainder of the lab, we will go over some quick case scenarios that require quality control. We will load in new molecular profile. Checking for Missing Values # get molecular profile tpm_matrix &lt;- pset@molecularProfiles[[&quot;rnaseq.tpm.batch&quot;]] |&gt; assay() |&gt; as.data.frame() tpm_matrix[1:5,1:5] #&gt; NCI-H23 HOP-62 SNB-75 HL-60(TB) A-549 #&gt; GENE001 90.5370190 75.59677 104.525210 42.18450 9.391661 #&gt; GENE002 75.5065358 22.05942 NA NA 82.203007 #&gt; GENE003 85.2218882 103.63729 8.646855 86.64833 42.742828 #&gt; GENE004 0.0749728 89.58816 19.705347 45.51081 75.588726 #&gt; GENE005 57.0379889 80.19416 92.440089 53.37649 66.238551 # get metadata meta &lt;- pset@molecularProfiles[[&quot;rnaseq.tpm.batch&quot;]] |&gt; colData() meta |&gt; head() #&gt; DataFrame with 6 rows and 2 columns #&gt; sampleid batchid #&gt; &lt;character&gt; &lt;numeric&gt; #&gt; NCI-H23 NCI-H23 1 #&gt; HOP-62 HOP-62 1 #&gt; SNB-75 SNB-75 1 #&gt; HL-60(TB) HL-60(TB) 2 #&gt; A-549 A-549 2 #&gt; SF268 SF268 2 For this exercise, we purposely put in a gene with many missing values. Let’s look for this gene. The code below will quantify the number of NA values in each row (gene). apply(tpm_matrix, 1, function(x) sum(is.na(x))) |&gt; head() #&gt; GENE001 GENE002 GENE003 GENE004 GENE005 GENE006 #&gt; 0 25 0 0 0 0 # tre_profiled$profiles # TODO: add code to make box plots for AAC and IC50 per drug # print only genes with NA values sum_NA &lt;- apply(tpm_matrix, 1, function(x) sum(is.na(x))) sum_NA[sum_NA &gt; 0] #&gt; GENE002 #&gt; 25 We see that GENE002 has 25 NA values. It is important to consider the proportion of NA values relative to the number of observations. We can quickly calculate the proportion: num_NA &lt;- sum_NA[sum_NA &gt; 0] |&gt; unname() num_observations &lt;- ncol(tpm_matrix) # get proportion num_NA / num_observations #&gt; [1] 0.5 Now we know that 50% of samples have an NA value rather than an expression level for GENE002. This can be indicative of some technical issue. Let’s remove this gene from downstream analysis. tpm_matrix &lt;- tpm_matrix[-which(rownames(tpm_matrix) == &quot;GENE002&quot;), ] any(is.na(tpm_matrix)) #&gt; [1] FALSE In the last line of code, we check if there were any remaining NA values. Since there are none, we can move on to visualizing our data. Principal Component Analysis for Outlier Removal Let’s quickly take a look at our expression matrix again. tpm_matrix[1:5, 1:5] #&gt; NCI-H23 HOP-62 SNB-75 HL-60(TB) A-549 #&gt; GENE001 90.5370190 75.59677 104.525210 42.18450 9.391661 #&gt; GENE003 85.2218882 103.63729 8.646855 86.64833 42.742828 #&gt; GENE004 0.0749728 89.58816 19.705347 45.51081 75.588726 #&gt; GENE005 57.0379889 80.19416 92.440089 53.37649 66.238551 #&gt; GENE006 26.4142662 74.16214 88.222117 96.38433 44.452740 The expression matrix is currently formatted such that the features (genes) are the rows and the samples (cells) are the columns. Since we want to do PCA to visualize the samples, we need to transpose the matrix so that the attributes of the samples (genes) are the columns instead. t_tpm_matrix &lt;- tpm_matrix |&gt; t() |&gt; as.data.frame() t_tpm_matrix[1:5, 1:5] #&gt; GENE001 GENE003 GENE004 GENE005 GENE006 #&gt; NCI-H23 90.537019 85.221888 0.0749728 57.03799 26.41427 #&gt; HOP-62 75.596766 103.637293 89.5881605 80.19416 74.16214 #&gt; SNB-75 104.525210 8.646855 19.7053470 92.44009 88.22212 #&gt; HL-60(TB) 42.184495 86.648331 45.5108051 53.37649 96.38433 #&gt; A-549 9.391661 42.742828 75.5887260 66.23855 44.45274 Once the expression matrix is in the correct format, we can perform PCA using the prcomp function. org_pca &lt;- prcomp(t_tpm_matrix)$x |&gt; as.data.frame() print(dim(org_pca)) #&gt; [1] 50 50 org_pca[1:5, 1:5] #&gt; PC1 PC2 PC3 PC4 PC5 #&gt; NCI-H23 -44.039730 -45.92050 63.97547 -9.390331 42.39060 #&gt; HOP-62 -9.862044 10.97767 -90.24025 40.301276 -27.50330 #&gt; SNB-75 16.981835 -43.81072 -16.12549 -1.423588 -42.08150 #&gt; HL-60(TB) 83.651364 10.58870 59.28436 -24.431547 6.36504 #&gt; A-549 8.510913 84.27694 59.59322 -9.085760 29.08710 To visualize the data, we plot the first two principal components (PCs). # add batch labels org_pca$Batch &lt;- meta$batchid[match(rownames(org_pca), meta$sampleid)] |&gt; as.factor() # plot p1 &lt;- ggplot(org_pca) + geom_point(aes(x = PC1, y = PC2, color = Batch), size = 5) + scale_color_manual(values = c(&quot;#624763&quot;, &quot;#B1D3A3&quot;)) + theme_classic() + ggtitle(&quot;Before Batch Correction&quot;) p1 There is a very obvious outlier in our data. We can quantitatively identify this outlier by identifying samples that lie beyond a threshold of 1.5 * IQR of the first and fourth quartiles. # extract PC scores for given PC scores &lt;- org_pca[[&quot;PC1&quot;]] # compute IQR of given PC iqr &lt;- IQR(scores) # compute upper and lower thresholds upp_thres &lt;- quantile(scores, 0.75) + 1.5 * iqr low_thres &lt;- quantile(scores, 0.25) - 1.5 * iqr # print samples with values beyond threshold outlier &lt;- rownames(org_pca)[which(scores &lt; low_thres | scores &gt; upp_thres)] paste(&quot;Outlier for PC1:&quot;, outlier) |&gt; print() #&gt; [1] &quot;Outlier for PC1: T-47D&quot; Let’s remove T-47D and re-plot our data. # remove outlier outlier &lt;- &quot;T-47D&quot; tpm_matrix[[outlier]] &lt;- NULL # redo PCA and plotting org_pca &lt;- prcomp(t(tpm_matrix))$x |&gt; as.data.frame() org_pca$Batch &lt;- meta$batchid[match(rownames(org_pca), meta$sampleid)] |&gt; as.factor() p1 &lt;- ggplot(org_pca) + geom_point(aes(x = PC1, y = PC2, color = Batch), size = 5) + scale_color_manual(values = c(&quot;#624763&quot;, &quot;#B1D3A3&quot;)) + theme_classic() + ggtitle(&quot;Before Batch Correction&quot;) p1 Now that the outlier is removed, we have a better visualization of the data. It is very evident that the data points (samples) tend to cluster by batch. This is indicative of a potential batch effect. Adjusting for Known Batches When we have a known batch, we can adjust for it directly. One method is to use the ComBat() function from the sva package. # adjust for known batch adj_tpm_matrix &lt;- ComBat( dat = tpm_matrix, batch = as.factor(meta$batchid[match(colnames(tpm_matrix), meta$sampleid)]), par.prior = TRUE, prior.plots = FALSE ) #&gt; Found2batches #&gt; Adjusting for0covariate(s) or covariate level(s) #&gt; Standardizing Data across genes #&gt; Fitting L/S model and finding priors #&gt; Finding parametric adjustments #&gt; Adjusting the Data adj_tpm_matrix[1:5, 1:5] #&gt; NCI-H23 HOP-62 SNB-75 HL-60(TB) A-549 #&gt; GENE001 81.991219 68.65465 94.477925 46.14868 9.844954 #&gt; GENE003 78.009018 94.55152 9.221893 94.18421 46.353576 #&gt; GENE004 2.112512 81.72158 19.570898 48.84136 82.434411 #&gt; GENE005 53.126927 73.84929 84.808130 57.36965 71.508314 #&gt; GENE006 25.252026 67.80845 80.339726 106.46140 48.702080 We can now perform PCA and visualize on our adjusted TPM counts matrix. We will compare the results to the original PCA visualization. Don’t forget to transpose the adjusted counts matrix! # perform PCA on adjusted matrix adj_pca &lt;- prcomp(t(adj_tpm_matrix))$x |&gt; as.data.frame() adj_pca$Batch &lt;- meta$batchid[match(rownames(adj_pca), meta$sampleid)] |&gt; as.factor() # create scatter plot p2 &lt;- ggplot(adj_pca) + geom_point(aes(x = PC1, y = PC2, color = Batch), size = 5) + scale_color_manual(values = c(&quot;#624763&quot;, &quot;#B1D3A3&quot;)) + theme_classic() + ggtitle(&quot;After Batch Correction&quot;) # plot both plots side by side for comparison ggarrange(p1, p2, ncol = 2) For downstream pharmacogenomic analysis (or any other bioinformatic analysis), the batch-corrected expression matrix should be used. For downstream pharmacogenomic analysis (or any other bioinformatic analysis), the batch-corrected expression matrix should be used. Lab Completed! Congratulations! You have completed Lab 2! "],["module-3-pharmacogenomics-for-biomarker-discover---basic-analysis.html", "Module 3: Pharmacogenomics for Biomarker Discover - Basic Analysis Lecture Lab", " Module 3: Pharmacogenomics for Biomarker Discover - Basic Analysis Lecture Lab Instructor(s) Name(s) and Contact Information Jermiah J. Joseph jermiah.joseph@uhn.ca Nikta Feizi nikta.feizi@uhn.ca Julia Nguyen julia.nguyen@uhn.ca PharmacoGx Package Overview PharmacoGx: An R package for analyzing pharmacogenomic datasets. Key Functions: Install and Load PharmacoGx install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;PharmacoGx&quot;) library(PharmacoGx) Download a PharmacoSet availablePSets() GDSC &lt;- downloadPSet(&quot;GDSC_2020(v2-8.2)&quot;) # downloadPSet(): Download pharmacogenomic datasets. Extract Drug Response Data drug_response &lt;- summarizeSensitivityProfiles(GDSC, sensitivity.measure=&#39;aac_recomputed&#39;) # summarizeSensitivityProfiles(): Summarize drug response data. Extract Gene Expression Data gene_expr &lt;- summarizeMolecularProfiles(GDSC, mDataType=&#39;rna&#39;) gene_expr_mtx &lt;- assay(gene_expr) Data Retrieval: availablePSets(): Lists available pharmacogenomic datasets. Downloading Multiple PharmacoSets: PSet.list &lt;- lapply(c(&quot;GDSC&quot;, &quot;CCLE&quot;, &quot;CTRP&quot;), downloadPSet) names(PSet.list) &lt;- c(&quot;GDSC&quot;, &quot;CCLE&quot;, &quot;CTRP&quot;) Accessing Molecular Profiles: molecular.data &lt;- lapply(PSet.list, function(pset) { summarizeMolecularProfiles(pset, mDataType = &#39;rna&#39;) }) Introduction In this workshop, we will explore data integration and comparative analysis using the PharmacoGx package, focusing on the GDSC and CCLE datasets. Specifically, we will cover drug sensitivity comparisons using AUC and IC50 measures and investigate correlations between gene expression profiles. This R Markdown file is designed to give participants hands-on experience with data exploration and interpretation. Learning Objectives Learn how to load and handle data from the GDSC and CCLE datasets. Understand how to summarize drug sensitivity profiles and molecular data. Perform correlations to assess concordance between cell line datasets. Visualize and interpret the results of statistical tests. Exploring GDSC and CCLE Datasets Load GDSC and CCLE Datasets We will use the GDSCsmall and CCLEsmall sample datasets provided by PharmacoGx to compare the two data sources. data(&quot;GDSCsmall&quot;) data(&quot;CCLEsmall&quot;) GDSCsmall #&gt; &lt;PharmacoSet&gt; #&gt; Name: GDSC #&gt; Date Created: Mon Aug 24 15:18:23 2015 #&gt; Number of samples: 10 #&gt; Molecular profiles: #&gt; RNA : #&gt; Dim: 300, 11 #&gt; rna2 : #&gt; Dim: 300, 9 #&gt; mutation : #&gt; Dim: 70, 10 #&gt; Treatment response: Drug pertubation: #&gt; Please look at pertNumber(cSet) to determine number of experiments for each drug-sample combination. #&gt; Drug sensitivity: #&gt; Number of Experiments: 972 #&gt; Please look at sensNumber(cSet) to determine number of experiments for each drug-sample combination. Find Common Genes Between GDSC and CCLE The first step in comparing datasets is to find shared features between them. Here, we identify the genes that are present in both datasets. commonGenes &lt;- intersect(fNames(GDSCsmall, &quot;rna&quot;), fNames(CCLEsmall, &quot;rna&quot;)) length(commonGenes) #&gt; [1] 41 There are 41 genes that are common between the RNA profiles of the GDSC and CCLE datasets. Identify Common Cell Lines and Drugs Next, we identify the common cell lines and drugs between GDSC and CCLE. common &lt;- intersectPSet( list(&quot;CCLE&quot; = CCLEsmall, &quot;GDSC&quot; = GDSCsmall), intersectOn = c(&quot;cell.lines&quot;, &quot;drugs&quot;), strictIntersect = TRUE ) #&gt; Intersecting large PSets may take a long time ... cellNames(common[[1]]) #&gt; [1] &quot;22RV1&quot; &quot;23132-87&quot; &quot;5637&quot; &quot;639-V&quot; &quot;647-V&quot; &quot;697&quot; &quot;769-P&quot; #&gt; [8] &quot;786-0&quot; &quot;8-MG-BA&quot; length(cellNames(common[[1]])) #&gt; [1] 9 There are 9 common samples between GDSC and CCLE. The intersectPSet function returns a list of the two PSets subsetted to include only the common cell lines. common #&gt; $CCLE #&gt; &lt;PharmacoSet&gt; #&gt; Name: CCLE #&gt; Date Created: Fri Nov 6 14:00:53 2015 #&gt; Number of samples: 9 #&gt; Molecular profiles: #&gt; RNA : #&gt; Dim: 50, 9 #&gt; RNAseq : #&gt; Dim: 50, 9 #&gt; mutation : #&gt; Dim: 1667, 9 #&gt; CNV : #&gt; Dim: 50, 7 #&gt; Treatment response: Drug pertubation: #&gt; Please look at pertNumber(cSet) to determine number of experiments for each drug-sample combination. #&gt; Drug sensitivity: #&gt; Number of Experiments: 102 #&gt; Please look at sensNumber(cSet) to determine number of experiments for each drug-sample combination. #&gt; #&gt; $GDSC #&gt; &lt;PharmacoSet&gt; #&gt; Name: GDSC #&gt; Date Created: Mon Aug 24 15:18:23 2015 #&gt; Number of samples: 9 #&gt; Molecular profiles: #&gt; RNA : #&gt; Dim: 300, 10 #&gt; rna2 : #&gt; Dim: 300, 9 #&gt; mutation : #&gt; Dim: 70, 9 #&gt; Treatment response: Drug pertubation: #&gt; Please look at pertNumber(cSet) to determine number of experiments for each drug-sample combination. #&gt; Drug sensitivity: #&gt; Number of Experiments: 79 #&gt; Please look at sensNumber(cSet) to determine number of experiments for each drug-sample combination. Notice that most of the molecular profiles are subsetted to include the 9 common samples. Some odd cases include RNA from GDSC which has a technical replicate (hence 10 samples) and CNV from CCLE which is missing CNV profiles for two of the nine cell lines. Summarize Drug Sensitivity Profiles We summarize drug sensitivity profiles (AUC and IC50) for each dataset. The summary.stat parameter can be set to different statistical metrics such as mean, median, etc. Here, we use the median for summarizing the sensitivity. # Summary statistics for AUC GDSC.auc &lt;- summarizeSensitivityProfiles( common$GDSC, sensitivity.measure = &quot;auc_published&quot;, summary.stat = &quot;median&quot;, verbose = FALSE ) CCLE.auc &lt;- summarizeSensitivityProfiles( common$CCLE, sensitivity.measure = &quot;auc_published&quot;, summary.stat = &quot;median&quot;, verbose = FALSE ) # Summary statistics for IC50 GDSC.ic50 &lt;- summarizeSensitivityProfiles( common$GDSC, sensitivity.measure = &quot;ic50_published&quot;, summary.stat = &quot;median&quot;, verbose = FALSE ) CCLE.ic50 &lt;- summarizeSensitivityProfiles( common$CCLE, sensitivity.measure = &quot;ic50_published&quot;, summary.stat = &quot;median&quot;, verbose = FALSE ) CCLE.auc |&gt; head() #&gt; 22RV1 23132-87 5637 639-V 647-V 697 769-P #&gt; PD-0325901 0.385000 NA 0.1708125 0.3088750 NA 0.2291000 0.23250000 #&gt; 17-AAG 0.372460 NA 0.4828250 0.4877500 NA 0.3420875 0.40937500 #&gt; Nilotinib 0.000000 NA 0.0072625 0.0710125 NA 0.1573375 0.00000000 #&gt; PHA-665752 0.094375 NA 0.0000000 0.0194000 NA 0.1609750 0.09427143 #&gt; lapatinib 0.036125 NA 0.2212250 0.0066000 NA 0.0453250 0.16475000 #&gt; Nutlin-3 0.076925 NA 0.0000000 0.0666625 NA 0.2588125 0.08598571 #&gt; 786-0 8-MG-BA #&gt; PD-0325901 0.13862500 0.0758750 #&gt; 17-AAG 0.44162500 0.4426500 #&gt; Nilotinib 0.07501250 NA #&gt; PHA-665752 0.07408625 0.3962500 #&gt; lapatinib 0.12987500 0.0547625 #&gt; Nutlin-3 0.00000000 0.0655125 We can visualize the distribution of drug sensitivity profiles to compare between the two psets. First we quickly reformat the data into a long format to facilitate plotting. We use the melt() function from the reshape2 package. CCLE_toPlot &lt;- melt(CCLE.auc) colnames(CCLE_toPlot) &lt;- c(&quot;Drug&quot;, &quot;Gene&quot;, &quot;AUC&quot;) CCLE_toPlot |&gt; head() #&gt; Drug Gene AUC #&gt; 1 PD-0325901 22RV1 0.385000 #&gt; 2 17-AAG 22RV1 0.372460 #&gt; 3 Nilotinib 22RV1 0.000000 #&gt; 4 PHA-665752 22RV1 0.094375 #&gt; 5 lapatinib 22RV1 0.036125 #&gt; 6 Nutlin-3 22RV1 0.076925 Next, we can create a quick box plot to visualize the AUC distributions per drug. ggplot(CCLE_toPlot, aes(x = Drug, y = AUC)) + geom_boxplot(fill = &quot;grey&quot;) + theme_classic() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) #rotate x-axis labels Let’s do this again but with the GDSC PSet so we can compare the two # format the CCLE sensitivity data GDSC_toPlot &lt;- melt(GDSC.auc) colnames(GDSC_toPlot) &lt;- c(&quot;Drug&quot;, &quot;Gene&quot;, &quot;AUC&quot;) # merge the two pset dataframes GDSC_toPlot$PSet &lt;- &quot;GDSC&quot; CCLE_toPlot$PSet &lt;- &quot;CCLE&quot; merge_toPlot &lt;- rbind(GDSC_toPlot, CCLE_toPlot) # plot to compare AUC distribution between PSets ggplot(merge_toPlot, aes(x = Drug, y = AUC)) + geom_boxplot(aes(fill = PSet)) + scale_fill_manual(values = c(&quot;#624763&quot;, &quot;#B1D3A3&quot;)) + theme_classic() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) #rotate x-axis labels Preclinical drug response data is fairly noisy, hence the variation we see between the two datasets. However, we do see some commonalities in distribution. Summarize Gene Expression Profiles We summarize gene expression data for the genes that are common between GDSC and CCLE. GDSCexpression &lt;- summarizeMolecularProfiles( common$GDSC, cellNames(common$GDSC), mDataType = &quot;rna&quot;, features = commonGenes, verbose = FALSE ) |&gt; assay() CCLEexpression &lt;- summarizeMolecularProfiles( common$CCLE, cellNames(common$CCLE), mDataType = &quot;rna&quot;, features = commonGenes, verbose = FALSE ) |&gt; assay() GDSCexpression |&gt; head() #&gt; 22RV1 23132-87 5637 639-V 647-V 697 #&gt; ENSG00000000003 5.890740 6.243345 10.018953 9.653157 10.039302 5.215355 #&gt; ENSG00000000005 4.448758 4.335738 4.108065 4.014940 4.250878 4.367339 #&gt; ENSG00000000419 10.427302 11.045576 11.611295 11.604278 11.248686 10.572231 #&gt; ENSG00000000457 5.905884 6.900556 5.684007 5.392485 5.748209 5.934834 #&gt; ENSG00000000460 6.010605 5.433439 5.729120 5.439058 6.453635 6.342021 #&gt; ENSG00000000938 4.410785 4.329849 4.397001 4.176387 4.275824 4.618786 #&gt; 769-P 786-0 8-MG-BA #&gt; ENSG00000000003 8.615450 7.304893 7.994002 #&gt; ENSG00000000005 4.722970 4.235424 4.447925 #&gt; ENSG00000000419 9.927782 10.825907 10.759706 #&gt; ENSG00000000457 6.475836 5.087249 4.994176 #&gt; ENSG00000000460 5.999142 5.001772 6.073944 #&gt; ENSG00000000938 5.003250 4.443563 4.797094 Here, you could do PCA on the profiles to quickly check the data. We will skip this step in the interest of time. Correlation Analysis Between GDSC and CCLE We perform correlation analysis to examine the relationship between gene expression, AUC, and IC50 measures across the GDSC and CCLE datasets using Spearman’s correlation. # get common cell line names cc &lt;- cellNames(common[[1]]) # correlation of gene expression across common cell lines ge.cor &lt;- sapply(cc, function(x, d1, d2) { stats::cor( d1[, x], d2[, x], method = &quot;spearman&quot;, use = &quot;pairwise.complete.obs&quot; ) }, d1 = GDSCexpression, d2 = CCLEexpression) ge.cor #&gt; 22RV1 23132-87 5637 639-V 647-V 697 769-P 786-0 #&gt; 0.8658537 0.8844948 0.8935540 0.9202091 0.9106272 0.8893728 0.8939024 0.8681185 #&gt; 8-MG-BA #&gt; 0.8470383 We can see that the RNA-Seq expression values are highly correlated across the common cell lines. Let’s take a look at the correlation of drug response, starting with IC50 values. # quick look at the CCLE IC50 data CCLE.ic50 |&gt; head() #&gt; 22RV1 23132-87 5637 639-V 647-V 697 769-P #&gt; PD-0325901 8.0000000 NA 8.00000000 8.0000000 NA 8.0000000 1.4542717 #&gt; 17-AAG 0.3297017 NA 0.07082279 0.1500945 NA 0.4225712 0.1517988 #&gt; Nilotinib 8.0000000 NA 7.47535467 8.0000000 NA 1.9104344 8.0000000 #&gt; PHA-665752 8.0000000 NA 8.00000000 8.0000000 NA 3.2754419 7.1504111 #&gt; lapatinib 7.8473053 NA 2.30776763 8.0000000 NA 0.8494762 1.0574611 #&gt; Nutlin-3 8.0000000 NA 8.00000000 8.0000000 NA 1.8905237 5.5913019 #&gt; 786-0 8-MG-BA #&gt; PD-0325901 8.0000000 8.0000000 #&gt; 17-AAG 0.2795302 0.2349526 #&gt; Nilotinib 8.0000000 NA #&gt; PHA-665752 8.0000000 8.0000000 #&gt; lapatinib 7.1780353 5.2266199 #&gt; Nutlin-3 8.0000000 8.0000000 # correlation of IC50 values across common drugs and cell lines ic50.cor &lt;- sapply(cc, function(x, d1, d2) { stats::cor( d1[, x], d2[, x], method = &quot;spearman&quot;, use = &quot;pairwise.complete.obs&quot; ) }, d1 = GDSC.ic50, d2 = CCLE.ic50) ic50.cor #&gt; 22RV1 23132-87 5637 639-V 647-V 697 769-P 786-0 #&gt; 0.4082483 NA 0.5713800 0.4082483 NA 0.6273461 0.6300619 0.6546537 #&gt; 8-MG-BA #&gt; 0.3664850 Notice that we have some NA values in the original CCLE IC50 dataset and in the correlation results. The pairwise.complete.obs argument used in the cor() function ensures that only complete observations (i.e. numeric values that are not NA) are included in the pairwise correlations. Since 23132-87 and 647-V are all NA values, no spearman correlation was computed. We can quickly compute the correlation for AUC as well. # correlation of AUC values across common drugs and cell lines auc.cor &lt;- sapply(cc, function(x, d1, d2) { stats::cor( d1[, x], d2[, x], method = &quot;spearman&quot;, use = &quot;pairwise.complete.obs&quot; ) }, d1 = GDSC.auc, d2 = CCLE.auc) auc.cor #&gt; 22RV1 23132-87 5637 639-V 647-V 697 769-P 786-0 #&gt; 0.0000000 NA 0.7748062 0.8214286 NA 0.3750000 0.8571429 0.4638168 #&gt; 8-MG-BA #&gt; 0.5414447 Statistical Comparison We compare the correlations using Wilcoxon signed-rank tests to see if there are significant differences between the gene expression correlations and the drug sensitivity correlations. w1 &lt;- stats::wilcox.test( x = ge.cor, y = auc.cor, conf.int = TRUE, exact = FALSE ) w2 &lt;- stats::wilcox.test( x = ge.cor, y = ic50.cor, conf.int = TRUE, exact = FALSE ) w1 #&gt; #&gt; Wilcoxon rank sum test with continuity correction #&gt; #&gt; data: ge.cor and auc.cor #&gt; W = 62, p-value = 0.001496 #&gt; alternative hypothesis: true location shift is not equal to 0 #&gt; 95 percent confidence interval: #&gt; 0.06309566 0.51857816 #&gt; sample estimates: #&gt; difference in location #&gt; 0.347967 w2 #&gt; #&gt; Wilcoxon rank sum test with continuity correction #&gt; #&gt; data: ge.cor and ic50.cor #&gt; W = 63, p-value = 0.001024 #&gt; alternative hypothesis: true location shift is not equal to 0 #&gt; 95 percent confidence interval: #&gt; 0.2407670 0.4857055 #&gt; sample estimates: #&gt; difference in location #&gt; 0.3179657 # Display p-values ss &lt;- sprintf(&quot;GE vs. AUC = %.1E\\nGE vs. IC50 = %.1E&quot;, w1$p.value, w2$p.value) cat(ss) #&gt; GE vs. AUC = 1.5E-03 #&gt; GE vs. IC50 = 1.0E-03 Boxplot Visualization The results are visualized using boxplots to compare the correlations across gene expression, AUC, and IC50. boxplot(list(&quot;GE&quot; = ge.cor, &quot;AUC&quot; = auc.cor, &quot;IC50&quot; = ic50.cor), main = &quot;Concordance between cell lines&quot;, ylab = expression(R[s]), sub = ss, ylim = c(-1, 1), col = &quot;lightgrey&quot;, pch = 20, border = &quot;black&quot; ) Statistical Analysis for Drug Response Associations In this final section, we will be focusing on computing the association between a feature of interest and drug response in order to identify predictive biomarkers. Let’s begin by selecting a feature and drug of interest to explore. commonGenes |&gt; head() #&gt; [1] &quot;ENSG00000000003&quot; &quot;ENSG00000000005&quot; &quot;ENSG00000000419&quot; &quot;ENSG00000000457&quot; #&gt; [5] &quot;ENSG00000000460&quot; &quot;ENSG00000000938&quot; feature &lt;- &quot;ENSG00000000003&quot; common$GDSC@treatment |&gt; rownames() #&gt; [1] &quot;PD-0325901&quot; &quot;17-AAG&quot; &quot;Nilotinib&quot; &quot;PHA-665752&quot; &quot;lapatinib&quot; #&gt; [6] &quot;Nutlin-3&quot; &quot;AZD0530&quot; &quot;Crizotinib&quot; &quot;Sorafenib&quot; &quot;PD-0332991&quot; #&gt; [11] &quot;paclitaxel&quot; &quot;AZD6244&quot; &quot;PLX4720&quot; &quot;TAE684&quot; &quot;Erlotinib&quot; drug &lt;- &quot;PD-0325901&quot; Next, we need to extract the vector of gene expression for our chosen feature and drug response for our chosen drug. Let’s do this for the GDSC dataset. Gene &lt;- GDSCexpression[feature,] Drug &lt;- GDSC.auc[drug,] Gene #&gt; 22RV1 23132-87 5637 639-V 647-V 697 769-P 786-0 #&gt; 5.890740 6.243345 10.018953 9.653157 10.039302 5.215355 8.615450 7.304893 #&gt; 8-MG-BA #&gt; 7.994002 Drug #&gt; 22RV1 23132-87 5637 639-V 647-V 697 769-P 786-0 #&gt; 0.029649 0.122911 0.007242 0.279261 0.100351 0.049681 0.179831 0.150231 #&gt; 8-MG-BA #&gt; 0.034754 Notice that the PSet has already kept the samples ordered across the various profiles. Before we compute the associations, we can quickly plot the two variables to visualize their relationship. # create datafarme to plot toPlot &lt;- data.frame(Gene = Gene, Drug = Drug) ggplot(toPlot, aes(x = Gene, y = Drug)) + geom_point() + theme_classic() + labs(x = &quot;Gene (expr)&quot;, y = &quot;Drug (AUC)&quot;) From the scatter plot, we see a weak positive correlation. Let’s see if this is reflected in our association analyses. Concordance Index Fist, we will compute the association between the gene expression data and drug response. We will use the concordance.index function from the survcomp package. ci &lt;- survcomp::concordance.index( as.numeric(Drug), # drug vector surv.time = as.numeric(Gene), # gene vector surv.event = rep(1,length(Gene)), outx = TRUE, method=&quot;noether&quot;, na.rm = TRUE ) cat(&quot;Concordance Index:&quot;, ci$c.index, &quot;\\n&quot;, &quot;P-value:&quot;, ci$p.value, &quot;\\n&quot;, &quot;Standard Error:&quot;, ci$se, &quot;\\n&quot;, &quot;Upper CI:&quot;, ci$upper,&quot;\\n&quot;, &quot;Lower CI:&quot;, ci$lower) #&gt; Concordance Index: 0.4166667 #&gt; P-value: 0.07592696 #&gt; Standard Error: 0.04695301 #&gt; Upper CI: 0.5086929 #&gt; Lower CI: 0.3246404 The concordance index tells us there is a weak inverse association between the gene expression and the drug response. Pearson’s Correlation Coefficient Using the same feature and drug, let’s compute the association again but this time using Pearson’s correlation. ps &lt;- cor.test( x = Gene, y = Drug, alternative = &quot;two.sided&quot;, method = &quot;pearson&quot; ) cat(&quot;Pearson&#39;s correlation:&quot;, ps$estimate, &quot;\\n&quot;, &quot;P-value:&quot;, ci$p.value, &quot;\\n&quot;, &quot;Confidence Interval:&quot;, ps$conf.int) #&gt; Pearson&#39;s correlation: 0.2937677 #&gt; P-value: 0.07592696 #&gt; Confidence Interval: -0.4601228 0.8015157 The Pearson’s correlation tells us there is a (very) weak positive linear relationship between the gene expression and the drug response. Notice the slight difference in interpretation between the concordance index and the Pearson’s correlation. Drug Sensitivity Signatures (PharmacoGx) The last method we will explore is a built-in function from the PharmacoGx package called drugSensitivitySig. This function takes a PharmacoSet along with a list of drugs and features, then computes the association between the feature expression and drug response for each pair. Let’s first select the first 3 genes and drugs as our features &amp; drugs of interest: features &lt;- commonGenes[1:3] drugs &lt;- rownames(common$GDSC@treatment)[1:3] features #&gt; [1] &quot;ENSG00000000003&quot; &quot;ENSG00000000005&quot; &quot;ENSG00000000419&quot; drugs #&gt; [1] &quot;PD-0325901&quot; &quot;17-AAG&quot; &quot;Nilotinib&quot; Now we can calculate the drug sensitivity signature using the vector of genes and drugs for the GDSC dataset. Note This gene-drug signature is based on univariable analysis. # gene expression signature sig.rna &lt;- drugSensitivitySig( object = GDSCsmall, mDataType = &quot;rna&quot;, drugs = drugs, features = features, sensitivity.measure = &quot;auc_published&quot;, molecular.summary.stat = &quot;median&quot;, sensitivity.summary.stat = &quot;median&quot;, modeling.method = &quot;pearson&quot;, verbose = FALSE ) sig.rna@.Data[,,c(1,5)] #&gt; , , estimate #&gt; #&gt; PD-0325901 17-AAG Nilotinib #&gt; ENSG00000000003 -0.18840373 -0.2369481 0.8554590 #&gt; ENSG00000000005 -0.14409315 -0.4756331 0.7875267 #&gt; ENSG00000000419 -0.02890968 0.5466780 -0.8239237 #&gt; #&gt; , , pvalue #&gt; #&gt; PD-0325901 17-AAG Nilotinib #&gt; ENSG00000000003 0.8793373 0.8477058 0.3465502 #&gt; ENSG00000000005 0.9079470 0.6844380 0.4227225 #&gt; ENSG00000000419 0.9815930 0.6317843 0.3835609 The output is a 3D array of genes x drugs x metric. Outputted are the estimate and pvalue. Feel free to explore the other array components in sig.rna@.Data. This function is a powerful method for investigating the univariate relationship between multiple molecular features and drugs. Let’s do the same for mutations, we’ll do a quick example using one gene and drug from the CCLE dataset. # mutation signature sig.mut &lt;- drugSensitivitySig( object = CCLEsmall, mDataType = &quot;mutation&quot;, drugs = &quot;PD-0325901&quot;, features = &quot;BRAF&quot;, sensitivity.measure = &quot;auc_published&quot;, molecular.summary.stat = &quot;and&quot;, sensitivity.summary.stat = &quot;median&quot;, verbose = FALSE ) sig.mut@.Data[,,c(1,6)] #&gt; estimate pvalue #&gt; 8.251857e-01 1.612881e-09 Univariate vs Multivariate Analysis For the final section of this lab, we will explore univariate vs multivariate linear modeling. Let’s start with a simple univariate linear model using the same Gene and Drug vector from earlier. Univariate Analysis Recall Gene is the RNA expression vector of ENSG00000000005 and Drug is the drug response vector (AUC) for PD-0325901 in the GDSC dataset. lm(Drug ~ Gene) |&gt; summary() #&gt; #&gt; Call: #&gt; lm(formula = Drug ~ Gene) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -0.12867 -0.04835 -0.01884 0.05239 0.14848 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) -0.004639 0.139300 -0.033 0.974 #&gt; Gene 0.014028 0.017253 0.813 0.443 #&gt; #&gt; Residual standard error: 0.08965 on 7 degrees of freedom #&gt; Multiple R-squared: 0.0863, Adjusted R-squared: -0.04423 #&gt; F-statistic: 0.6612 on 1 and 7 DF, p-value: 0.4429 Let’s break down this output: Residuals: the difference between the predicted y (drug response) values and the actual y values. A larger range suggests the model may not be a good fit of the data. Coefficients: the parameters of the model. Estimate can be considered the effect size. Specifically, it is the one-unit change in the y variable (drug response) per one-unit change in the x variable (gene expression). The estimate from our drug~gene association is 0.014028. Pr(&gt;|t|) is the corresponding p-value for each estimate. The p-value from our drug~gene association test is 0.443. Note If any of the coefficients had met the p-value &lt; 0.05 significance threshold, you would have seen * beside the estimate (unfortunately, this association does not meet this threshold). Let’s see if we can make a multi-variate model with better performance. # get another gene vector commonGenes[2] #&gt; [1] &quot;ENSG00000000005&quot; Gene2 &lt;- GDSCexpression[commonGenes[2],] # multi-variate model lm(Drug ~ Gene + Gene2) |&gt; summary() #&gt; #&gt; Call: #&gt; lm(formula = Drug ~ Gene + Gene2) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -0.13292 -0.04715 -0.02147 0.04840 0.14047 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 0.15618 0.84445 0.185 0.859 #&gt; Gene 0.01251 0.02017 0.620 0.558 #&gt; Gene2 -0.03441 0.17780 -0.194 0.853 #&gt; #&gt; Residual standard error: 0.09653 on 6 degrees of freedom #&gt; Multiple R-squared: 0.09197, Adjusted R-squared: -0.2107 #&gt; F-statistic: 0.3038 on 2 and 6 DF, p-value: 0.7487 The second gene feature we are adding to our model is ENSG00000000005. Take a look at the output, comparing it to the previous model we ran. Do you think that adding an additional gene has improved model performance? Individual Practice For the remainder of the lab, please explore the associations between other features and drug response. Try using the CCLE pset too! Lab Completed! Congratulations! You have completed Lab 3! "],["module-4-pharmacogenomics-for-biomarker-discovery---advanced-analysis.html", "Module 4: Pharmacogenomics for Biomarker Discovery - Advanced Analysis Lecture Lab", " Module 4: Pharmacogenomics for Biomarker Discovery - Advanced Analysis Lecture Lab Overview Intructor(s) Name and Contact Information Nikta Feizi nikta.feizi@uhn.ca Julia Nguyen julia.nguyen@uhn.ca Introduction This workshop will touch on more advanced statistical methods for univariate biomarker discovery. It will primarily cover meta-analysis techniques and sub-group analysis. Learning Objectives By the end of this lab, participants will be able to: Execute a meta-analysis using multiple PharmacoSets to evaluate a biomarker of interest across different cancer types Generate and interpret forest plots to visualize effect sizes Perform subgroup analyses using a small subset of the CCLE dataset Understand the preprocessing steps required for pharmacogenomic data Assess the assumptions and model diagnostics for linear regression models Data Acquisition and Preparation Like before, we will use smaller versions of the PharmacoSets for the workshop to minimize processing time. Let’s load these datasets in and subset for common cell lines and . # load in the datasets data(&quot;GDSCsmall&quot;) data(&quot;CCLEsmall&quot;) Extracting Required Vectors for Biomarker Analysis Recall there are two components needed for a biomarker association analysis: Feature data (molecular profile) Drug response Say we are interested in ENSG00000003987 expression association with PD-0325901. We can start by extracting this data from both PSets. Gene Expression Data # specify our gene of interest gene &lt;- &quot;ENSG00000003987&quot; # extract the RNA-Seq data for our gene of interest in both GDSC and CCLE ccle_rna_data &lt;- summarizeMolecularProfiles( CCLEsmall, mDataType = &quot;rna&quot;, features = gene ) |&gt; assay() gdsc_rna_data &lt;- summarizeMolecularProfiles( GDSCsmall, mDataType = &quot;rna&quot;, features = gene ) |&gt; assay() #&gt; | | | 0% | |======================================================================| 100% gdsc_rna_data #&gt; 22RV1 23132-87 380 5637 639-V 647-V 697 #&gt; ENSG00000003987 4.197327 4.022529 4.000509 4.031896 3.977781 3.834624 4.36307 #&gt; 769-P 786-0 8-MG-BA #&gt; ENSG00000003987 4.397028 3.973001 4.275385 Drug Response Data Next, let’s take a look at the available drug response data sensitivityProfiles(CCLEsmall) |&gt; head() #&gt; ic50_published auc_published amax_published #&gt; drugid_AEW541_1321N1 8.000000 0.0873750 -42.55801 #&gt; drugid_AEW541_22Rv1 2.329924 0.2205000 -71.58934 #&gt; drugid_AEW541_42-MG-BA 2.682130 0.1144375 -63.49137 #&gt; drugid_AEW541_5637 5.002314 0.1243550 -62.35278 #&gt; drugid_AEW541_639-V 1.736181 0.1936250 -51.95981 #&gt; drugid_AEW541_697 4.260822 0.1087625 -73.33379 #&gt; auc_recomputed ic50_recomputed amax_recomputed #&gt; drugid_AEW541_1321N1 0.1017047 13.09700 42.87563 #&gt; drugid_AEW541_22Rv1 0.2239774 2.18654 70.37213 #&gt; drugid_AEW541_42-MG-BA 0.1215999 2.68981 63.00413 #&gt; drugid_AEW541_5637 0.1092448 5.19939 61.43152 #&gt; drugid_AEW541_639-V 0.1912847 5.40523 54.22604 #&gt; drugid_AEW541_697 0.1146054 4.17688 69.94055 We can see a few options of drug response metrics to choose from. We will use auc_published for our drug response associations. # extract AUC_published data from CCLE and GDSC ccle_auc &lt;- summarizeSensitivityProfiles( CCLEsmall, sensitivity.measure = &quot;auc_published&quot;, summary.stat = &quot;median&quot;, verbose = FALSE ) gdsc_auc &lt;- summarizeSensitivityProfiles( GDSCsmall, sensitivity.measure = &quot;auc_published&quot;, summary.stat = &quot;median&quot;, verbose = FALSE ) ccle_auc[1:5,1:5] #&gt; 1321N1 143B 22RV1 23132-87 253J-BV #&gt; PD-0325901 0.1148875 NA 0.385000 NA NA #&gt; 17-AAG 0.4177000 NA 0.372460 NA NA #&gt; AEW541 0.0873750 NA 0.220500 NA NA #&gt; Nilotinib NA NA 0.000000 NA NA #&gt; PHA-665752 0.0333750 NA 0.094375 NA NA The summarizeSensitivityProfiles() function nicely pulls the drug response data and converts it into a sample~drug matrix for easy use. We only need the drug response data for PD-0325901, so let’s pull that out. drug &lt;- &quot;PD-0325901&quot; ccle_drug_data &lt;- ccle_auc[drug, ] gdsc_drug_data &lt;- gdsc_auc[drug, ] head(ccle_drug_data) #&gt; 1321N1 143B 22RV1 23132-87 253J-BV 253J #&gt; 0.1148875 NA 0.3850000 NA NA NA head(gdsc_drug_data) #&gt; 22RV1 23132-87 380 5637 639-V 647-V #&gt; 0.029649 0.122911 NA 0.007242 0.279261 0.100351 Gene Expression Exploratory Data Analysis (EDA) Before performing the statistical analysis, let’s quickly look at the distribution of ENSG00000003987 expression data. First, we can check the number of cell lines in each vector: paste(&quot;Number of cell lines in GDSC:&quot;, length(gdsc_rna_data)) #&gt; [1] &quot;Number of cell lines in GDSC: 10&quot; paste(&quot;Number of cell lines in CCLE:&quot;, length(ccle_rna_data)) #&gt; [1] &quot;Number of cell lines in CCLE: 1061&quot; Notice there is a large difference between the number of samples between GDSC and CCLE. This difference in sample size may reflected in the meta-analysis. Let’s quickly look at the distribution of this gene in both PSets. p1 &lt;- ggplot(data = t(ccle_rna_data), aes_string(x = gene)) + geom_histogram(bins = 30, fill = &quot;skyblue&quot;, color = &quot;black&quot;) + labs( title = stringr::str_c(&quot;Distribution of &quot;, gene, &quot; Expression in CCLEsmall&quot;), x = &quot;Expression&quot;, y = &quot;Frequency&quot; ) p2 &lt;- ggplot(data = t(gdsc_rna_data), aes_string(x = gene)) + geom_histogram(bins = 30, fill = &quot;skyblue&quot;, color = &quot;black&quot;) + labs( title = stringr::str_c(&quot;Distribution of &quot;, gene, &quot; Expression in GDSCsmall&quot;), x = &quot;Expression&quot;, y = &quot;Frequency&quot; ) ggarrange(p1, p2, ncol = 2) Notice that the difference in distribution shapes. You can imagine what implications a small sample size (e.g. GDSC) would have when downstream analysis. Effect Size Calculation In this next section, we will compute the associations between our feature and drug within each individual PSet. These results will be what we input into the meta-analysis. Before we start, let’s confirm that the samples in our input ENSG00000003987 expression and PD-0325901 response vectors are in the samae order. table(names(gdsc_drug_data) == colnames(gdsc_rna_data)) #&gt; #&gt; TRUE #&gt; 10 table(names(ccle_drug_data) == colnames(ccle_rna_data)) #&gt; #&gt; TRUE #&gt; 1061 # manually look at the cell line names names(gdsc_drug_data) #&gt; [1] &quot;22RV1&quot; &quot;23132-87&quot; &quot;380&quot; &quot;5637&quot; &quot;639-V&quot; &quot;647-V&quot; #&gt; [7] &quot;697&quot; &quot;769-P&quot; &quot;786-0&quot; &quot;8-MG-BA&quot; colnames(gdsc_rna_data) #&gt; [1] &quot;22RV1&quot; &quot;23132-87&quot; &quot;380&quot; &quot;5637&quot; &quot;639-V&quot; &quot;647-V&quot; #&gt; [7] &quot;697&quot; &quot;769-P&quot; &quot;786-0&quot; &quot;8-MG-BA&quot; We can use any of the statistical methods discussed in Module 3 to calculate theeffect size of the association between ENSG00000003987 expression and PD-0325901 response. Let’s try using concordance index: # fixing drug response data (to change in subsetted PSet) gdsc_drug_data[3] &lt;- 0.1 # compute concordance index for each pset CCLE_ci &lt;- survcomp::concordance.index( as.numeric(ccle_drug_data), # drug vector surv.time = as.numeric(ccle_rna_data), # gene vector surv.event = rep(1,length(ccle_rna_data)), outx = TRUE, method=&quot;noether&quot;, na.rm = TRUE ) cat(&quot;Concordance Index:&quot;, CCLE_ci$c.index, &quot;\\n&quot;, &quot;P-value:&quot;, CCLE_ci$p.value, &quot;\\n&quot;, &quot;Standard Error:&quot;, CCLE_ci$se, &quot;\\n&quot;, &quot;Upper CI:&quot;, CCLE_ci$upper,&quot;\\n&quot;, &quot;Lower CI:&quot;, CCLE_ci$lower) #&gt; Concordance Index: 0.5352986 #&gt; P-value: 0.01556791 #&gt; Standard Error: 0.0145929 #&gt; Upper CI: 0.5639002 #&gt; Lower CI: 0.5066971 GDSC_ci &lt;- survcomp::concordance.index( as.numeric(gdsc_drug_data), # drug vector surv.time = as.numeric(gdsc_rna_data), # gene vector surv.event = rep(1,length(gdsc_rna_data)), outx = TRUE, method=&quot;noether&quot;, na.rm = TRUE ) cat(&quot;Concordance Index:&quot;, GDSC_ci$c.index, &quot;\\n&quot;, &quot;P-value:&quot;, GDSC_ci$p.value, &quot;\\n&quot;, &quot;Standard Error:&quot;, GDSC_ci$se, &quot;\\n&quot;, &quot;Upper CI:&quot;, GDSC_ci$upper,&quot;\\n&quot;, &quot;Lower CI:&quot;, GDSC_ci$lower) #&gt; Concordance Index: 0.5777778 #&gt; P-value: 0.08389382 #&gt; Standard Error: 0.04499657 #&gt; Upper CI: 0.6659694 #&gt; Lower CI: 0.4895861 Perform Meta-Analysis Now we can combine the effect sizes from GDSCsmall and CCLEsmall to perform a meta-analysis. Recall from the lecture that we need three variables for our meta-analysis: Effect Size (also called Treatment Effect or TE) Standard Error Dataset Labels (just for plotting purposes) Let’s extract all of this information from our outputs above and put it into a dataframe. combined &lt;- data.frame( Concordance.Index = c(GDSC_ci$c.index, CCLE_ci$c.index), Standard.Error = c(GDSC_ci$se, CCLE_ci$se), Upper.CI = c(GDSC_ci$upper, CCLE_ci$upper), Lower.CI = c(GDSC_ci$lower, CCLE_ci$lower), Dataset = c(&quot;GDSC&quot;, &quot;CCLE&quot;) ) combined #&gt; Concordance.Index Standard.Error Upper.CI Lower.CI Dataset #&gt; 1 0.5777778 0.04499657 0.6659694 0.4895861 GDSC #&gt; 2 0.5352986 0.01459290 0.5639002 0.5066971 CCLE Now we can use the metagen function from the meta package to perform the meta-analysis. meta.result &lt;- metagen(data = combined, TE = Concordance.Index, seTE = Standard.Error, studlab = combined$Dataset ) meta.result #&gt; Number of studies: k = 2 #&gt; #&gt; 95%-CI z p-value #&gt; Common effect model 0.5393 [0.5121; 0.5665] 38.85 0 #&gt; Random effects model 0.5393 [0.5121; 0.5665] 38.85 0 #&gt; #&gt; Quantifying heterogeneity: #&gt; tau^2 = 0; tau = 0; I^2 = 0.0%; H = 1.00 #&gt; #&gt; Test of heterogeneity: #&gt; Q d.f. p-value #&gt; 0.81 1 0.3692 #&gt; #&gt; Details of meta-analysis methods: #&gt; - Inverse variance method #&gt; - Restricted maximum-likelihood estimator for tau^2 #&gt; - Calculation of I^2 based on Q Visualization with Forest Plots Forest Function from Meta Package We can use the built in forest function from the meta package to quickly create a forest plot using the output of the metagen function: # set your file path file_path &lt;- &quot;forest_plot.png&quot; # generate forest plot png(file = file_path, width = 10, height = 4, res = 600, units = &quot;in&quot;) forest(meta.result) dev.off() #&gt; quartz_off_screen #&gt; 2 ###### Using ggplot2 We can also visualize this data usign the ggplot2 package. While this will not return a full forest plot, we can get a closer look at the relationship between the effect sizes of each individual dataset and the meta-estimate. ggplot(combined, aes(x = Concordance.Index, y = Dataset)) + geom_point(size = 3) + geom_errorbarh(aes(xmin = Lower.CI, xmax = Upper.CI), height = 0.2) + geom_vline(xintercept = meta.result$TE.random, linetype = &quot;dashed&quot;, color = &quot;red&quot;) + labs( title = &quot;Meta-Analysis of GeneX Expression and Drug Response&quot;, x = &quot;Effect Size&quot;, y = &quot;Study&quot; ) + theme_minimal() In the plot above, we have each data point representing the individual dataset effect sizes, the error bars represents the confidence interval, and the vertical line representing the meta-analysis treatment estimate. We can very clearly see that the red line is closer to the CCLE data point compared to the GDSC data point. This is reflective of the CCLE having a greater weight dueto a lower variance among other considerations. Subgroup Analysis We will now conduct a tissue-subgroup analysis using a subset of the CCLEsmall dataset, using all the steps that we have learned from this workshop. We will be looking at the response of RNA-Seq data on AUC drug response. We will take a discovery approach, looking for any associations in our rich dataset. Data Preparation Let’s start by loading in and looking at our data. # load in expression data expr &lt;- summarizeMolecularProfiles(CCLEsmall, mDataType=&#39;rna&#39;) |&gt; assay() expr[1:5,1:5] #&gt; 1321N1 143B 22RV1 23132-87 253J-BV #&gt; ENSG00000181019 10.907043 9.773744 8.907329 13.961104 12.258347 #&gt; ENSG00000157764 7.072053 6.553047 7.237172 7.462726 7.190695 #&gt; ENSG00000000003 4.052251 10.542824 7.951917 8.079243 10.079808 #&gt; ENSG00000000005 3.430694 3.585748 3.524705 3.580134 3.651864 #&gt; ENSG00000000419 13.477683 12.891333 12.043700 12.200771 12.133981 # load in drug response data auc &lt;- summarizeSensitivityProfiles( CCLEsmall, sensitivity.measure = &quot;auc_published&quot;, summary.stat = &quot;median&quot;, verbose = FALSE ) auc[1:5,1:5] #&gt; 1321N1 143B 22RV1 23132-87 253J-BV #&gt; PD-0325901 0.1148875 NA 0.385000 NA NA #&gt; 17-AAG 0.4177000 NA 0.372460 NA NA #&gt; AEW541 0.0873750 NA 0.220500 NA NA #&gt; Nilotinib NA NA 0.000000 NA NA #&gt; PHA-665752 0.0333750 NA 0.094375 NA NA We have our RNA-Seq expression and drug response matrix in the feature~sample format. Next, let’s load in the metadata for the cell lines. # load in metadata meta &lt;- CCLEsmall@molecularProfiles[[&quot;rna&quot;]] |&gt; colData() colnames(meta) #&gt; [1] &quot;samplename&quot; &quot;filename&quot; #&gt; [3] &quot;chiptype&quot; &quot;hybridization.date&quot; #&gt; [5] &quot;hybridization.hour&quot; &quot;file.day&quot; #&gt; [7] &quot;file.hour&quot; &quot;batch&quot; #&gt; [9] &quot;sampleid&quot; &quot;CCLE.name&quot; #&gt; [11] &quot;Cell.line.primary.name&quot; &quot;Cell.line.aliases&quot; #&gt; [13] &quot;Gender&quot; &quot;Site.Primary&quot; #&gt; [15] &quot;Histology&quot; &quot;Hist.Subtype1&quot; #&gt; [17] &quot;Notes&quot; &quot;Source&quot; #&gt; [19] &quot;Expression.arrays&quot; &quot;SNP.arrays&quot; #&gt; [21] &quot;Oncomap&quot; &quot;Hybrid.Capture.Sequencing&quot; #&gt; [23] &quot;batchid&quot; &quot;rownames&quot; Since we want to do a tissue subgroup analysis, we need to identify the variable that gives us the tissue type for each cell line. We also need to find the variable that maps to the column names of our expr matrix. Then, we make sure that all our samples are present in this metadata # show needed column names meta[,c(&#39;Cell.line.primary.name&#39;, &#39;Site.Primary&#39;)] |&gt; head() #&gt; DataFrame with 6 rows and 2 columns #&gt; Cell.line.primary.name #&gt; &lt;character&gt; #&gt; NIECE_P_NCLE_RNA3_HG-U133_PLUS_2_B06_296024 1321N1 #&gt; MAKER_P_NCLE_RNA7_HG-U133_PLUS_2_F09_454702 143B #&gt; NIECE_P_NCLE_RNA3_HG-U133_PLUS_2_F06_296120 22Rv1 #&gt; WATCH_P_NCLE_RNA8_HG-U133_PLUS_2_E11_474718 23132/87 #&gt; CRAZY_P_NCLE_RNA10_HG-U133_PLUS_2_A05_569490 253J-BV #&gt; CRAZY_P_NCLE_RNA10_HG-U133_PLUS_2_A03_569510 253J #&gt; Site.Primary #&gt; &lt;character&gt; #&gt; NIECE_P_NCLE_RNA3_HG-U133_PLUS_2_B06_296024 central_nervous_system #&gt; MAKER_P_NCLE_RNA7_HG-U133_PLUS_2_F09_454702 bone #&gt; NIECE_P_NCLE_RNA3_HG-U133_PLUS_2_F06_296120 prostate #&gt; WATCH_P_NCLE_RNA8_HG-U133_PLUS_2_E11_474718 stomach #&gt; CRAZY_P_NCLE_RNA10_HG-U133_PLUS_2_A05_569490 urinary_tract #&gt; CRAZY_P_NCLE_RNA10_HG-U133_PLUS_2_A03_569510 urinary_tract # check for cell lines included in metadata colnames(expr) %in% meta$Cell.line.primary.name |&gt; table() #&gt; #&gt; FALSE TRUE #&gt; 125 936 Notice we have some cell lines not included in the metadata. We will want to remove these samples from our analysis as we cannot give them a tissue label. # identify cell lines with both expression and metadata commonCells &lt;- intersect(colnames(expr), meta$Cell.line.primary.name) paste(&quot;Number of common cell lines:&quot;, length(commonCells)) #&gt; [1] &quot;Number of common cell lines: 936&quot; # check that all these cell lines also have drug response data commonCells %in% colnames(auc) |&gt; table() #&gt; #&gt; TRUE #&gt; 936 # subset metadata to only include these samples meta &lt;- meta[meta$Cell.line.primary.name %in% commonCells,] dim(meta) #&gt; [1] 936 24 There were 936 cell lines with all RNA-Seq expression, drug response, and metadata. We only keep the metadata for these cell lines. Next, let’s take a look at the tissue types available within the samples we have. meta$Site.Primary |&gt; table() #&gt; #&gt; autonomic_ganglia biliary_tract #&gt; 15 7 #&gt; bone breast #&gt; 26 56 #&gt; central_nervous_system endometrium #&gt; 59 24 #&gt; haematopoietic_and_lymphoid_tissue kidney #&gt; 168 32 #&gt; large_intestine liver #&gt; 52 26 #&gt; lung oesophagus #&gt; 175 26 #&gt; ovary pancreas #&gt; 47 38 #&gt; pleura prostate #&gt; 10 5 #&gt; salivary_gland skin #&gt; 1 55 #&gt; soft_tissue stomach #&gt; 20 31 #&gt; thyroid upper_aerodigestive_tract #&gt; 11 29 #&gt; urinary_tract #&gt; 23 We have a large range of different tissue types represented in our CCLE dataset. Let’s select haematopoietic_and_lymphoid_tissue and lung tissues as they have the largest sample sizes. Let’s subset our PSets for each of these tissue types. # get cell lines from each tissue lymp_cells &lt;- meta$Cell.line.primary.name[meta$Site.Primary == &quot;haematopoietic_and_lymphoid_tissue&quot;] lung_cells &lt;- meta$Cell.line.primary.name[meta$Site.Primary == &quot;lung&quot;] # subset psets to only include cells within each tissue group lymp_pset &lt;- subsetTo(CCLEsmall, cells = lymp_cells) lung_pset &lt;- subsetTo(CCLEsmall, cells = lung_cells) # quickly check dimensions of the assays in our subsetted psets assay(summarizeMolecularProfiles(lymp_pset, mDataType=&#39;rna&#39;)) |&gt; dim() #&gt; [1] 50 168 All our molecular profiles and drug response data within each tissue-specific pset is now subsetted to only include the cell lines that are in the respective tissue. Statistical Analysis to Measure Drug Response Associations Let’s say we want to discover a gene (biomarker) that is predictive of response to the drug lapatinib. To do that, we will compute the association between the expression of each gene to the lapatinib drug response. First, let’s get our assays: # extract the expression assays lymp_expr &lt;- assay(summarizeMolecularProfiles(lymp_pset, mDataType=&#39;rna&#39;)) lung_expr &lt;- assay(summarizeMolecularProfiles(lung_pset, mDataType=&#39;rna&#39;)) # extract the drug response assays lymp_auc &lt;- summarizeSensitivityProfiles(lymp_pset, sensitivity.measure = &quot;auc_published&quot;, summary.stat = &quot;median&quot;, verbose = FALSE) lung_auc &lt;- summarizeSensitivityProfiles(lung_pset, sensitivity.measure = &quot;auc_published&quot;, summary.stat = &quot;median&quot;, verbose = FALSE) # extract just the drug response vector for lapatinib drug &lt;- &quot;lapatinib&quot; lymp_auc &lt;- lymp_auc[drug,] lung_auc &lt;- lung_auc[drug,] # quickly view the data lymp_expr[1:5,1:5] #&gt; 697 ALL-SIL AML-193 AMO-1 BCP-1 #&gt; ENSG00000181019 6.609914 7.032188 7.637502 9.810762 10.006768 #&gt; ENSG00000157764 7.754090 7.138147 7.228066 8.115521 7.197811 #&gt; ENSG00000000003 4.509136 4.072092 3.937972 5.118464 3.846667 #&gt; ENSG00000000005 3.736073 3.661470 3.770592 3.803109 3.660946 #&gt; ENSG00000000419 11.718635 11.769529 12.287833 12.586162 11.837654 lymp_auc[1:5] #&gt; 697 ALL-SIL AML-193 AMO-1 BCP-1 #&gt; 0.0453250 0.0767875 NA 0.0663875 NA The PSet has already ensured that the cell line order between the RNA-Seq expression matrix and the drug response vector is the same. Don’t forget to always check when working with your own data. Now we will have to compute the association between each gene to lapatinib. We can use a for loop to quickly do this: # create data frame to hold results results &lt;- as.data.frame(matrix(data = NA, nrow = 0, ncol = 7)) colnames(results) &lt;- c(&quot;gene&quot;, &quot;drug&quot;, &quot;ci&quot;, &quot;pvalue&quot;, &quot;se&quot;, &quot;upper&quot;, &quot;lower&quot;) # get the number of genes (features) num_genes &lt;- nrow(lymp_expr) # loop through every gene to compute concordance index to drug responses for (gene in rownames(lymp_expr)) { # compute concordance index ci &lt;- survcomp::concordance.index( as.numeric(lymp_auc), # drug vector surv.time = as.numeric(lymp_expr[gene,]), # gene vector surv.event = rep(1,length(lymp_expr[gene,])), outx = TRUE, method=&quot;noether&quot;, na.rm = TRUE ) # extract summary statistics gene_result &lt;- data.frame(gene, drug, ci = ci$c.index, pvalue = ci$p.value, se = ci$se, upper = ci$upper, lower = ci$lower) # merge with results dataframe results &lt;- rbind(results, gene_result) } # filtering and multiple test correction results &lt;- results[complete.cases(results$pvalue),] results$FDR &lt;- p.adjust(results$pvalue, method = &quot;BH&quot;, n = length(results$pvalue)) results |&gt; head() #&gt; gene drug ci pvalue se upper lower #&gt; 1 ENSG00000181019 lapatinib 0.5497723 0.30681314 0.04870411 0.6452306 0.4543140 #&gt; 2 ENSG00000157764 lapatinib 0.5191932 0.72503712 0.05456734 0.6261432 0.4122432 #&gt; 3 ENSG00000000003 lapatinib 0.4528302 0.38826533 0.05467268 0.5599867 0.3456737 #&gt; 4 ENSG00000000005 lapatinib 0.4547820 0.37310423 0.05076826 0.5542860 0.3552781 #&gt; 5 ENSG00000000419 lapatinib 0.4925179 0.86910085 0.04540095 0.5815021 0.4035337 #&gt; 6 ENSG00000000457 lapatinib 0.6005205 0.06179093 0.05381779 0.7060014 0.4950396 #&gt; FDR #&gt; 1 0.8522587 #&gt; 2 0.9062964 #&gt; 3 0.8688491 #&gt; 4 0.8688491 #&gt; 5 0.9516488 #&gt; 6 0.7079522 Notice at the end we also computed the false discovery rate (FDR) which is a method for multiple test correction. We would have to repeat this code for every tissue type. Although we are only working with two, imagine we wanted to do more tissue types in the future. Function for computing concordance index To simply this, we can turn the code above into a function such that we just have to input the expression matrix and drug response vector to get our result without having to change the rest of the code. Below is a function named compute_CI which takes two arguments: expr: an expression matrix with features as rows and samples as columns drug_vector: a vector of drug response in the same order as the samples in expr drug: string name of drug (just for putting in the results dataframe) compute_CI &lt;- function(expr, drug_vector, drug) { # create data frame to hold results results &lt;- as.data.frame(matrix(data = NA, nrow = 0, ncol = 7)) colnames(results) &lt;- c(&quot;gene&quot;, &quot;drug&quot;, &quot;ci&quot;, &quot;pvalue&quot;, &quot;se&quot;, &quot;upper&quot;, &quot;lower&quot;) # get the number of genes (features) num_genes &lt;- nrow(expr) # loop through every gene to compute concordance index to drug responses for (gene in rownames(expr)) { # compute concordance index ci &lt;- survcomp::concordance.index( as.numeric(drug_vector), # drug vector surv.time = as.numeric(expr[gene,]), # gene vector surv.event = rep(1,length(expr[gene,])), outx = TRUE, method=&quot;noether&quot;, na.rm = TRUE ) # extract summary statistics gene_result &lt;- data.frame(gene, drug, ci = ci$c.index, pvalue = ci$p.value, se = ci$se, upper = ci$upper, lower = ci$lower) # merge with results dataframe results &lt;- rbind(results, gene_result) } # filtering and multiple test correction results &lt;- results[complete.cases(results$pvalue),] results$FDR &lt;- p.adjust(results$pvalue, method = &quot;BH&quot;, n = length(results$pvalue)) results$FDRsig &lt;- ifelse(results$FDR &lt; 0.05, &#39;FDR Sig&#39;, &#39;Not FDR Sig&#39;) # output results return(results) } # use this function on both our lymp and lung data lymp_results &lt;- compute_CI(expr = lymp_expr, drug_vector = lymp_auc, drug = drug) lung_results &lt;- compute_CI(expr = lung_expr, drug_vector = lung_auc, drug = drug) lymp_results |&gt; head() #&gt; gene drug ci pvalue se upper lower #&gt; 1 ENSG00000181019 lapatinib 0.5497723 0.30681314 0.04870411 0.6452306 0.4543140 #&gt; 2 ENSG00000157764 lapatinib 0.5191932 0.72503712 0.05456734 0.6261432 0.4122432 #&gt; 3 ENSG00000000003 lapatinib 0.4528302 0.38826533 0.05467268 0.5599867 0.3456737 #&gt; 4 ENSG00000000005 lapatinib 0.4547820 0.37310423 0.05076826 0.5542860 0.3552781 #&gt; 5 ENSG00000000419 lapatinib 0.4925179 0.86910085 0.04540095 0.5815021 0.4035337 #&gt; 6 ENSG00000000457 lapatinib 0.6005205 0.06179093 0.05381779 0.7060014 0.4950396 #&gt; FDR FDRsig #&gt; 1 0.8522587 Not FDR Sig #&gt; 2 0.9062964 Not FDR Sig #&gt; 3 0.8688491 Not FDR Sig #&gt; 4 0.8688491 Not FDR Sig #&gt; 5 0.9516488 Not FDR Sig #&gt; 6 0.7079522 Not FDR Sig We also added a column called FDRsig which represents if the association met the FDR &lt; 5% threshold. This will help us in plotting. Visualizing Feature-drug Associations Now that we have the associations between all our genes with lapatinib response for both our tissue groups, let’s visualize the distribution of the computed associations. Let’s first rank by concordance index. lymp_results &lt;- lymp_results[order(lymp_results$ci),] lung_results &lt;- lung_results[order(lung_results$ci),] lymp_results |&gt; head() #&gt; gene drug ci pvalue se upper #&gt; 40 ENSG00000003400 lapatinib 0.4014314 0.07602913 0.05555649 0.5103201 #&gt; 14 ENSG00000001461 lapatinib 0.4098894 0.08110842 0.05166032 0.5111418 #&gt; 10 ENSG00000001036 lapatinib 0.4131425 0.10091227 0.05294747 0.5169176 #&gt; 35 ENSG00000003096 lapatinib 0.4183474 0.11327235 0.05155958 0.5194024 #&gt; 46 ENSG00000003989 lapatinib 0.4255042 0.14509404 0.05112672 0.5257108 #&gt; 25 ENSG00000002586 lapatinib 0.4294079 0.17377225 0.05189897 0.5311281 #&gt; lower FDR FDRsig #&gt; 40 0.2925426 0.7079522 Not FDR Sig #&gt; 14 0.3086370 0.7079522 Not FDR Sig #&gt; 10 0.3093674 0.7079522 Not FDR Sig #&gt; 35 0.3172925 0.7079522 Not FDR Sig #&gt; 46 0.3252977 0.7254702 Not FDR Sig #&gt; 25 0.3276878 0.7898739 Not FDR Sig Next, we will create a waterfall plot. We’ve created a function to do so, the function is named plot_waterfall and takes the following arguments: ci_results: results matrix from the compute_CI function tissue: string of the tissue type # create palette pal &lt;- c(&#39;FDR Sig&#39; = &quot;#B1D3A3&quot;, &#39;Not FDR Sig&#39; = &quot;gray&quot;) # function to plot waterfall plots plot_waterfall &lt;- function(ci_results, tissue) { # minor formating for plotting ci_results$rank &lt;- 1:nrow(ci_results) ci_results$rank &lt;- as.factor(ci_results$rank) ci_results$drug &lt;- as.factor(ci_results$drug) # create waterfall plot ggplot(ci_results, aes(x = ci - 0.5, y = rank)) + geom_col(aes(fill = FDRsig), color = &quot;black&quot;) + scale_x_continuous(limits = c(-0.5, 0.5), labels = function(x) x + 0.5) + scale_y_discrete(breaks = ci_results$rank, labels = ci_results$gene) + geom_vline(xintercept = 0) + scale_fill_manual(&quot;FDR Significance&quot;, values = pal) + theme_classic() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(y = &quot;Gene&quot;, title = tissue, x = &quot;Concordance Index (CI)&quot;) + coord_flip() } # call the function on our lymp and lung results plot_waterfall(lymp_results, &#39;Haematopoietic &amp; Lymphoid&#39;) plot_waterfall(lung_results, &#39;Lung&#39;) Notice that there are no FDR significant associations within the lymp data, but there are some from the lung data. If you inspect closely, you can also see that the genes with the most predictive power (low and high CI values) are different between the two tissue types. Identifying candidate biomarkers We see some FDR significant associations in our lung data. Let’s extract those genes. lung_sig &lt;- lung_results[lung_results$FDR &lt; 0.05,] lung_sig #&gt; gene drug ci pvalue se upper #&gt; 3 ENSG00000000003 lapatinib 0.3532213 2.812853e-05 0.03504651 0.4219112 #&gt; 26 ENSG00000002587 lapatinib 0.3789916 3.713691e-04 0.03399460 0.4456198 #&gt; 9 ENSG00000000971 lapatinib 0.3837535 3.707483e-04 0.03265282 0.4477519 #&gt; 31 ENSG00000002834 lapatinib 0.3882353 1.091398e-03 0.03422234 0.4553099 #&gt; 40 ENSG00000003400 lapatinib 0.4028011 5.219215e-03 0.03479861 0.4710051 #&gt; 48 ENSG00000004139 lapatinib 0.6196078 1.663106e-04 0.03176533 0.6818667 #&gt; lower FDR FDRsig #&gt; 3 0.2845314 0.001406427 FDR Sig #&gt; 26 0.3123634 0.004642114 FDR Sig #&gt; 9 0.3197552 0.004642114 FDR Sig #&gt; 31 0.3211607 0.010913980 FDR Sig #&gt; 40 0.3345971 0.043493456 FDR Sig #&gt; 48 0.5573489 0.004157765 FDR Sig There are 6 genes that have FDR significant associations with lapatinib response. Of these 6, the most predictive is ENSG00000000003 which is associated with resistance (CI &lt; 0.5). A next possible step would be to take some of these genes and assess their association in lung tissue-derived cell lines from another PSet (do a meta-analysis!) Interactive Exercise Task1: Compare the fixed-effects and random-effects models using the effect sizes using a new gene-drug pair. Examine the variability across different the two studies. Use the I² and Q-statistics to assess heterogeneity. # perform meta analysis on GDSC and CCLE on a new gene-drug pair # Once you have your meta.result, you can use the code below to examine the Q and I-squared statistics #cat(&quot;Q Statistic:&quot;, meta.result$Q, &quot;\\n&quot;) #cat(&quot;I-squared Statistic:&quot;, meta.result$I2, &quot;%\\n&quot;) Task2: Perform a subgroup analysis on a new tissue type. # do a tissue subtype analysis on a new tissue type, reporting any candidate biomarkers Lab Completed! Congratulations! You have completed Lab 4! "]]
